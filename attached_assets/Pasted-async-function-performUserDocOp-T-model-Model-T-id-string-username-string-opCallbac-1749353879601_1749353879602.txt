async function performUserDocOp<T>(
  model: Model<T>,
  id: string,
  username: string,
  opCallback: (m: Model<T>, i: string, u: string) => Promise<T | null>
): Promise<T | null> { //(declare performUserDocOp utility)
  console.log(`${opCallback.name} is running with ${id}, ${username}`); //(log start)
  try { //(start try)
    const doc = await opCallback(model, id, username); //(execute provided op)
    console.log(`${opCallback.name} is returning ${doc}`); //(log return)
    return doc; //(return operation result)
  } catch (error) { //(catch errors)
    console.error(`${opCallback.name} error`, error); //(log error)
    if (error instanceof mongoose.Error.CastError) { //(check invalid id)
      console.log(`${opCallback.name} is returning null due to CastError`); //(log CastError)
      return null; //(return null on CastError)
    }
    throw error; //(rethrow for caller)
  }
}

/**
 * Finds a document by id and username
 *
 * Wraps model.findOne and centralizes user ownership checks for reusability.
 */
async function findUserDoc<T>(model: Model<T>, id: string, username: string): Promise<T | null> { //(declare findUserDoc utility)
  const op = async function findUserDoc(m: Model<T>, i: string, u: string): Promise<T | null> {
    return m.findOne({ _id: i, user: u } as any); //(query user doc)
  };
  return performUserDocOp(model, id, username, op); //(run op via helper)
}

/**
 * Deletes a document by id and username
 *
 * Wraps model.findOneAndDelete for consistent deletion and user checks.
 */
async function deleteUserDoc<T>(model: Model<T>, id: string, username: string): Promise<T | null> { //(declare deleteUserDoc utility)
  const op = async function deleteUserDoc(m: Model<T>, i: string, u: string): Promise<T | null> {
    return m.findOneAndDelete({ _id: i, user: u } as any); //(delete user doc)
  };
  return performUserDocOp(model, id, username, op); //(run op via helper)
}

/**
 * Executes a document action and sends 404 if missing
 *
 * Centralizes logic for fetching or deleting a user owned document. This
 * helper keeps controller utilities DRY while remaining generic for different
 * actions.
 */
async function userDocActionOr404<T>(
  model: Model<T>,
  id: string,
  user: string,
  res: Response,
  action: (m: Model<T>, i: string, u: string) => Promise<T | null>,
  msg: string
): Promise<T | undefined> { //(declare userDocActionOr404 utility)
  console.log(`userDocActionOr404 is running with ${id}, ${user}`); //(log start)
  try { //(start try)
    const doc = await action(model, id, user); //(perform find or delete)
    if (doc == null) { //(check not found or invalid id)
      sendNotFound(res, msg); //(send 404 response)
      console.log(`userDocActionOr404 is returning undefined`); //(log no doc)
      return; //(exit when missing)
    }
    console.log(`userDocActionOr404 is returning ${doc}`); //(log doc)
    return doc; //(return doc)
  } catch (error) { //(catch errors)
    console.error('userDocActionOr404 error', error); //(log error)
    throw error; //(rethrow for caller)
  }
}

/**
 * Fetches a user document or sends a 404 response
 *
 * Combines findUserDoc with not-found handling for repeated use in controllers.
 */
async function fetchUserDocOr404<T>(model: Model<T>, id: string, user: string, res: Response, msg: string): Promise<T | undefined> { //(declare fetchUserDocOr404 utility)
  console.log(`fetchUserDocOr404 is running with ${id}, ${user}`); //(log start)
  try { //(start try)
    const doc = await userDocActionOr404(model, id, user, res, findUserDoc, msg); //(delegate to action helper)
    if (!doc) { //(check undefined from helper)
      console.log(`fetchUserDocOr404 is returning undefined`); //(log undefined)
      return; //(exit when missing)
    }
    console.log(`fetchUserDocOr404 is returning ${doc}`); //(log return doc)
    return doc; //(return doc)
  } catch (error) { //(catch errors)
    console.error('fetchUserDocOr404 error', error); //(log error)
    throw error; //(rethrow for controller)
  }
}

/**
 * Deletes a user document or sends a 404 response
 *
 * Combines deleteUserDoc with not-found handling for repeated use in controllers.
 */
async function deleteUserDocOr404<T>(model: Model<T>, id: string, user: string, res: Response, msg: string): Promise<T | undefined> { //(declare deleteUserDocOr404 utility)
  console.log(`deleteUserDocOr404 is running with ${id}, ${user}`); //(log start)
  try { //(start try)
    const doc = await userDocActionOr404(model, id, user, res, deleteUserDoc, msg); //(delegate to action helper)
    if (!doc) { //(check undefined from helper)
      console.log(`deleteUserDocOr404 is returning undefined`); //(log undefined)
      return; //(exit when missing)
    }
    console.log(`deleteUserDocOr404 is returning ${doc}`); //(log return doc)
    return doc; //(return doc)
  } catch (error) { //(catch errors)
    console.error('deleteUserDocOr404 error', error); //(log error)
    throw error; //(rethrow for controller)
  }
}

/**
 * Lists documents owned by a user with optional sorting
 *
 * Wraps model.find for reuse across controllers.
 */
async function listUserDocs<T>(model: Model<T>, username: string, sort: Record<string, 1 | -1>): Promise<T[]> { //(declare listUserDocs utility with strict sort order)
  console.log(`listUserDocs is running with ${username}, ${JSON.stringify(sort)}`); //(log start)
  try { //(start try)
    const docs = await model.find({ user: username } as any).sort(sort as Record<string, SortOrder>); //(query user docs with sort cast)
    console.log(`listUserDocs is returning ${docs}`); //(log return)
    return docs; //(return docs)
  } catch (error) { //(catch errors)
    console.error('listUserDocs error', error); //(log error)
    throw error; //(rethrow)
  }
}

/**
 * Creates and saves a new document if the unique query has no match
 *
 * Centralizes duplicate checks and saves for repeated use in controllers.
 */
async function createUniqueDoc<T>(
  model: Model<T>,
  fields: Record<string, any>,
  uniqueQuery: Record<string, any>,
  res: Response,
  duplicateMsg: string
): Promise<T | undefined> { //(declare createUniqueDoc utility)
  console.log(`createUniqueDoc is running with ${JSON.stringify(fields)}`); //(log start)
  try { //(start try)
    if (!(await ensureUnique(model, uniqueQuery, res, duplicateMsg))) { //(check uniqueness)
      console.log('createUniqueDoc is returning undefined'); //(log duplicate)
      return; //(exit when duplicate found)
    }
    const doc = new model(fields); //(construct document)
    const saved = await doc.save(); //(persist document)
    console.log(`createUniqueDoc is returning ${saved}`); //(log return)
    return saved; //(return saved document)
  } catch (error) { //(catch errors)
    console.error('createUniqueDoc error', error); //(log error)
    throw error; //(rethrow)
  }
}

/**
 * Updates a document owned by a user after optional uniqueness check
 *
 * Combines fetchUserDocOr404 and ensureUnique for repeated update logic.
 */
async function updateUserDoc<T>(
  model: Model<T>,
  id: string,
  username: string,
  fieldsToUpdate: Record<string, any>,
  uniqueQuery: Record<string, any> | undefined,
  res: Response,
  duplicateMsg: string
): Promise<T | undefined> { //(declare updateUserDoc utility)
  console.log(`updateUserDoc is running with ${id}, ${username}`); //(log start)
  try { //(start try)
    const doc = await fetchUserDocOr404(model, id, username, res, 'Document not found'); //(fetch existing doc)
    if (!doc) { //(exit when missing)
      console.log('updateUserDoc is returning undefined'); //(log undefined)
      return; //(exit)
    }
    if (
      uniqueQuery &&
      Object.keys(uniqueQuery).some(
        (key) => key in fieldsToUpdate && (doc as any)[key] !== fieldsToUpdate[key]
      )
    ) { //(only check when updatable unique fields change)
      if (!(await ensureUnique(model, uniqueQuery, res, duplicateMsg))) { //(check duplicates)
        console.log('updateUserDoc is returning undefined'); //(log duplicate)
        return; //(exit when duplicate found)
      }
    }
    Object.assign(doc as any, fieldsToUpdate); //(apply field updates)
    await (doc as any).save(); //(persist updated doc)
    console.log(`updateUserDoc is returning ${doc}`); //(log return)
    return doc as T; //(return updated doc)
  } catch (error) { //(catch errors)
    console.error('updateUserDoc error', error); //(log error)
    throw error; //(rethrow)
  }
}

export { findUserDoc, deleteUserDoc, fetchUserDocOr404, deleteUserDocOr404, listUserDocs, createUniqueDoc, updateUserDoc }; //(export utilities with updater)