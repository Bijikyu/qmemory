Memory/Database Modules
@codex/circuit-breaker-factory
Purpose: Circuit breaker factory with lifecycle management and memory leak prevention.

Explanation:
This module provides a sophisticated circuit breaker factory that manages the lifecycle of multiple circuit breakers with automatic cleanup and memory management. It implements LRU (Least Recently Used) eviction for breaker management, periodic cleanup of idle breakers, and comprehensive statistics for monitoring. The factory is particularly valuable for applications that create many circuit breakers for different services or domains and need to prevent memory leaks.

The factory includes support for domain-specific breaker configurations, automatic cleanup based on usage patterns, and graceful shutdown handling that ensures all resources are properly released.

/**
 * @file Circuit Breaker Factory
 * @description Factory for managing circuit breaker lifecycle with cleanup and memory management
 * 
 * Rationale: Circuit breakers create memory leaks when not properly managed
 * Factory pattern ensures consistent creation, monitoring, and cleanup
 * Supports auto-scaling of breakers based on load patterns
 */
import { createCircuitBreaker } from './circuitBreaker.js';
export interface CircuitBreakerConfig {
  failureThreshold?: number;
  timeout?: number;
  resetTimeout?: number;
  monitoringPeriod?: number;
  maxConcurrent?: number;
}
export interface CircuitBreakerStats {
  domain: string;
  failures: number;
  successes: number;
  state: 'closed' | 'open' | 'half-open';
  lastFailureTime?: number;
  createdTime: number;
  lastUsedTime: number;
}
/**
 * Circuit Breaker Factory with lifecycle management
 * Rationale: Prevents memory leaks and provides centralized management
 */
class CircuitBreakerFactory {
  private breakers = new Map<string, any>();
  private cleanupInterval: NodeJS.Timeout | null = null;
  private readonly maxBreakers = 100; // Maximum cached breakers
  private readonly cleanupIntervalMs = 60000; // 1 minute cleanup interval
  private readonly breakerTimeoutMs = 300000; // 5 minutes breaker lifetime
  constructor() {
    this.startCleanupInterval();
  }
  /**
   * Get or create circuit breaker for domain
   * Rationale: Ensures single breaker per domain with consistent configuration
   */
  getCircuitBreaker(domain: string, config?: CircuitBreakerConfig): any {
    let breaker = this.breakers.get(domain);
    
    if (!breaker) {
      // Create new breaker with default config
      breaker = createCircuitBreaker({
        failureThreshold: config?.failureThreshold ?? 5,
        timeout: config?.timeout ?? 60000,
        resetTimeout: config?.resetTimeout ?? 120000,
        monitoringPeriod: config?.monitoringPeriod ?? 300000
      });
      // Add metadata for tracking
      (breaker as any)._domain = domain;
      (breaker as any)._createdTime = Date.now();
      (breaker as any)._lastUsedTime = Date.now();
      this.breakers.set(domain, breaker);
      
      // Enforce maximum breaker limit
      if (this.breakers.size > this.maxBreakers) {
        this.enforceBreakerLimit();
      }
    } else {
      // Update last used time
      (breaker as any)._lastUsedTime = Date.now();
    }
    return breaker;
  }
  /**
   * Enforce maximum breaker limit by removing least recently used
   * Rationale: Prevents unbounded memory growth
   */
  private enforceBreakerLimit(): void {
    const entries = Array.from(this.breakers.entries());
    
    // Sort by last used time (oldest first)
    entries.sort(([, a], [, b]) => {
      const timeA = (a as any)._lastUsedTime || 0;
      const timeB = (b as any)._lastUsedTime || 0;
      return timeA - timeB;
    });
    // Remove oldest breakers to maintain limit
    const toRemove = entries.slice(0, entries.length - this.maxBreakers);
    toRemove.forEach(([domain]) => {
      this.removeCircuitBreaker(domain);
    });
  }
  /**
   * Remove specific circuit breaker
   * Rationale: Cleanup for domains no longer in use
   */
  removeCircuitBreaker(domain: string): boolean {
    const breaker = this.breakers.get(domain);
    if (breaker) {
      try {
        // Call cleanup if available
        if (typeof breaker.destroy === 'function') {
          breaker.destroy();
        }
      } catch (error) {
        console.warn(`Error destroying circuit breaker for ${domain}:`, error);
      }
      
      this.breakers.delete(domain);
      return true;
    }
    return false;
  }
  /**
   * Start periodic cleanup interval
   * Rationale: Automatically removes unused breakers to prevent memory leaks
   */
  private startCleanupInterval(): void {
    this.cleanupInterval = setInterval(() => {
      this.performCleanup();
    }, this.cleanupIntervalMs);
  }
  /**
   * Perform cleanup of old and unused circuit breakers
   * Rationale: Removes breakers that haven't been used recently
   */
  private performCleanup(): void {
    const now = Date.now();
    const toRemove: string[] = [];
    this.breakers.forEach((breaker, domain) => {
      const lastUsed = (breaker as any)._lastUsedTime || 0;
      const created = (breaker as any)._createdTime || 0;
      
      // Remove if unused for timeout period
      if (now - lastUsed > this.breakerTimeoutMs) {
        toRemove.push(domain);
      }
      // Also remove very old breakers (safety net)
      else if (now - created > this.breakerTimeoutMs * 2) {
        toRemove.push(domain);
      }
    });
    toRemove.forEach(domain => {
      this.removeCircuitBreaker(domain);
    });
    if (toRemove.length > 0) {
      console.log(`Cleaned up ${toRemove.length} idle circuit breakers`);
    }
  }
  /**
   * Get statistics for all circuit breakers
   * Rationale: Provides monitoring data for performance tuning
   */
  getStats(): CircuitBreakerStats[] {
    const stats: CircuitBreakerStats[] = [];
    
    this.breakers.forEach((breaker, domain) => {
      const breakerState = this.getBreakerState(breaker);
      stats.push({
        domain,
        failures: breakerState.failures || 0,
        successes: breakerState.successes || 0,
        state: breakerState.state || 'closed',
        lastFailureTime: breakerState.lastFailureTime,
        createdTime: (breaker as any)._createdTime || 0,
        lastUsedTime: (breaker as any)._lastUsedTime || 0
      });
    });
    return stats.sort((a, b) => b.lastUsedTime - a.lastUsedTime);
  }
  /**
   * Extract state information from breaker
   * Rationale: Normalizes breaker state for monitoring
   */
  private getBreakerState(breaker: any): any {
    try {
      return {
        state: breaker.getState?.() || 'closed',
        failures: breaker.getFailures?.() || 0,
        successes: breaker.getSuccesses?.() || 0,
        lastFailureTime: breaker.getLastFailureTime?.()
      };
    } catch {
      return { state: 'closed' };
    }
  }
  /**
   * Get factory-level statistics
   * Rationale: Provides overview of circuit breaker pool health
   */
  getFactoryStats() {
    return {
      totalBreakers: this.breakers.size,
      maxBreakers: this.maxBreakers,
      cleanupIntervalMs: this.cleanupIntervalMs,
      breakerTimeoutMs: this.breakerTimeoutMs,
      uptime: process.uptime()
    };
  }
  /**
   * Force cleanup of all circuit breakers
   * Rationale: Manual cleanup for testing or emergency situations
   */
  clearAllBreakers(): void {
    console.log(`Clearing all ${this.breakers.size} circuit breakers`);
    
    const domains = Array.from(this.breakers.keys());
    domains.forEach(domain => {
      this.removeCircuitBreaker(domain);
    });
    
    this.breakers.clear();
  }
  /**
   * Graceful shutdown
   * Rationale: Ensures clean termination of all resources
   */
  shutdown(): void {
    console.log('Shutting down circuit breaker factory...');
    
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
    this.clearAllBreakers();
    console.log('Circuit breaker factory shutdown complete');
  }
}
// Global factory instance
const circuitBreakerFactory = new CircuitBreakerFactory();
/**
 * Get circuit breaker for domain with factory management
 * Rationale: Provides managed circuit breaker with automatic lifecycle
 */
export function getManagedCircuitBreaker(domain: string, config?: CircuitBreakerConfig): any {
  return circuitBreakerFactory.getCircuitBreaker(domain, config);
}
/**
 * Get circuit breaker factory statistics
 * Rationale: Provides monitoring data for performance tuning
 */
export function getCircuitBreakerStats(): CircuitBreakerStats[] {
  return circuitBreakerFactory.getStats();
}
/**
 * Get factory statistics
 * Rationale: Provides overview of circuit breaker pool health
 */
export function getCircuitBreakerFactoryStats() {
  return circuitBreakerFactory.getFactoryStats();
}
/**
 * Clear all circuit breakers
 * Rationale: Manual cleanup for testing or emergency situations
 */
export function clearAllCircuitBreakers(): void {
  circuitBreakerFactory.clearAllBreakers();
}
// Graceful shutdown handler
const handleShutdown = () => {
  circuitBreakerFactory.shutdown();
};
process.on('SIGINT', handleShutdown);
process.on('SIGTERM', handleShutdown);
export { CircuitBreakerFactory };