/**
 * Enhanced Caching Middleware for Scalability
 * 
 * Uses lru-cache library for production-tested LRU functionality
 * with Redis fallback and qmemory integration for unified metrics
 */

// Use any types for now to focus on the main refactoring
import { LRUCache } from 'lru-cache';

type Request = any;
type Response = any;
type NextFunction = any;
import qmemory from 'qmemory'; // Use qmemory for unified metrics and behavior

interface CacheConfig {
  ttlMs: number;
  maxSize?: number;
  keyGenerator?: (req: Request) => string;
  condition?: (req: Request) => boolean;
  invalidationStrategy?: 'ttl' | 'lru' | 'manual';
}

// Global cache instances using lru-cache with container limits
const caches = new Map<string, LRUCache<string, any>>();
const MAX_CACHE_INSTANCES = 50; // Prevent unlimited cache container growth
let redisClient: any = null;

// Initialize Redis client if available
async function initializeRedis() {
  try {
    const localVars = await import('../config/localVars.js');
    if (localVars.REDIS_HOST && !redisClient) {
      const Redis = (await import('ioredis')).default;
      const redisPort = typeof localVars.REDIS_PORT === 'string' 
        ? parseInt(localVars.REDIS_PORT, 10) 
        : (localVars.REDIS_PORT || 6379);
      
      redisClient = new Redis(redisPort, localVars.REDIS_HOST, {
        maxRetriesPerRequest: 3,
        lazyConnect: true
      });
      
      redisClient.on('error', (err: Error) => {
        console.error('Redis cache error, falling back to memory:', err.message);
        redisClient = null;
      });
    }
  } catch (error) {
    console.log('Redis not available for caching, using in-memory fallback');
  }
}

// Initialize Redis on module load with error handling
initializeRedis().catch(error => {
  console.warn('Failed to initialize Redis for enhanced caching:', error);
});

/**
 * Create enhanced caching middleware using lru-cache
 */
export function createCache(cacheName: string, config: CacheConfig) {
  const {
    ttlMs,
    maxSize = 1000,
    keyGenerator = (req) => `${req.method}:${req.path}:${req.ip}`,
    condition = () => true,
    invalidationStrategy = 'ttl'
  } = config;

  // Get or create cache instance using lru-cache with container limit enforcement
  let cache = caches.get(cacheName);
  if (!cache) {
    // Enforce container limit to prevent memory leaks
    if (caches.size >= MAX_CACHE_INSTANCES) {
      const oldestKey = caches.keys().next().value;
      caches.delete(oldestKey);
      console.warn(`Cache container limit reached, removed: ${oldestKey}`);
    }
    
    cache = new LRUCache<string, any>({
      max: maxSize,
      ttl: ttlMs,
      allowStale: false,
      updateAgeOnGet: true,
      dispose: (value, key) => {
        // Optional cleanup when items are evicted
        console.debug(`Cache evicted: ${key}`);
      }
    });
    caches.set(cacheName, cache);
  }

  return async (req: Request, res: Response, next: NextFunction) => {
    // Skip caching if condition not met
    if (!condition(req)) {
      return next();
    }

    const cacheKey = keyGenerator(req);

    try {
      // Try Redis first if available
      if (redisClient) {
        const cachedData = await redisClient.get(cacheKey);
        if (cachedData) {
          // OPTIMIZED: Avoid JSON.parse for simple responses that can be stored directly
          const parsed = cachedData.startsWith('{') || cachedData.startsWith('[') 
            ? JSON.parse(cachedData) 
            : cachedData;
          res.set('X-Cache', 'HIT');
          res.set('X-Cache-Source', 'Redis');
          return res.json(parsed);
        }
      } else {
        // Fallback to lru-cache - stores parsed objects directly
        const cachedData = cache.get(cacheKey);
        if (cachedData !== undefined) {
          res.set('X-Cache', 'HIT');
          res.set('X-Cache-Source', 'LRU-Cache');
          return res.json(cachedData);
        }
      }

      // Cache miss - continue processing
      res.set('X-Cache', 'MISS');

      // Override res.json to cache response
      const originalJson = res.json;
      res.json = function(data: any) {
        // Cache the response
        const dataToCache = JSON.stringify(data);
        
        if (redisClient) {
          redisClient.setex(cacheKey, Math.ceil(ttlMs / 1000), dataToCache);
        } else {
          cache.set(cacheKey, data);
        }

        // Send original response
        return originalJson.call(this, data);
      };

      next();

    } catch (error) {
      console.error('Cache middleware error:', error);
      next(); // Continue without caching on error
    }
  };
}

/**
 * Cache invalidation middleware
 */
export function invalidateCache(cacheName: string, keyPattern?: string) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const cache = caches.get(cacheName);
      if (cache) {
        if (keyPattern) {
          // Invalidate matching keys using lru-cache API
          for (const key of cache.keys()) {
            if (key.includes(keyPattern)) {
              cache.delete(key);
            }
          }
        } else {
          // Clear entire cache
          cache.clear();
        }
      }

      // Also invalidate Redis cache if available
      if (redisClient) {
        if (keyPattern) {
          const keys = await redisClient.keys(`*${keyPattern}*`);
          if (keys && keys.length > 0) {
            await redisClient.del(...keys);
          }
        } else {
          // Clear all cache entries for this application
          const appPrefix = process.env.APP_NAME || 'QreditCharge';
          const keys = await redisClient.keys(`${appPrefix}:*`);
          if (keys && keys.length > 0) {
            await redisClient.del(...keys);
          }
        }
      }

      res.set('X-Cache-Invalidated', 'true');
      next();

    } catch (error) {
      console.error('Cache invalidation error:', error);
      next();
    }
  };
}

/**
 * Get cache statistics for monitoring using lru-cache API
 */
export function getCacheStatistics(): Record<string, any> {
  const stats: Record<string, any> = {};
  
  for (const [cacheName, cache] of caches.entries()) {
    const cacheStats = cache.dump();
    const memUsage = process.memoryUsage();
    const totalMemory = require('os').totalmem();
    const memoryUsageRatio = memUsage.heapUsed / totalMemory;
    
    stats[cacheName] = {
      size: cache.size,
      maxSize: cache.max,
      calculatedSize: cache.calculatedSize,
      itemCount: Array.from(cache.keys()).length,
      memoryUsage: memUsage.heapUsed,
      memoryUsageRatio: memoryUsageRatio,
      has: cache.has.bind(cache),
      keys: Array.from(cache.keys())
    };
  }

  return stats;
}

/**
 * Graceful shutdown for all caches
 */
export function shutdownCaches(): void {
  for (const cache of caches.values()) {
    cache.clear();
  }
  caches.clear();
}

export default {
  createCache,
  invalidateCache,
  getCacheStatistics,
  shutdownCaches
};