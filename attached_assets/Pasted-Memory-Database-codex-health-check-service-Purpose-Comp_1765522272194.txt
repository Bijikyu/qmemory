Memory/Database
@codex/health-check-service
Purpose: Comprehensive health monitoring service for applications and microservices. Explanation:
This module provides a complete health monitoring solution for Node.js applications, particularly useful in microservice architectures and containerized deployments. It solves the problem of service health visibility by offering comprehensive checks for system resources, dependencies, and application metrics. The service includes checks for worker threads, memory usage, CPU load, cache performance, and external dependencies like TensorFlow.js and Sharp image processing.

The module is essential for load balancers, monitoring systems, auto-scaling solutions, and container orchestration platforms that need to determine service health and readiness. It provides both detailed health reports and simple readiness/liveness endpoints for Kubernetes deployments.

/**
 * Health Check and Monitoring Service
 * 
 * Provides comprehensive health monitoring for the FaceQrop service
 * to support load balancers, monitoring systems, and auto-scaling.
 * 
 * Features:
 * - Service health status checks
 * - Resource usage monitoring
 * - Performance metrics collection
 * - Dependency health verification
 * - Graceful degradation reporting
 */
import type { Request, Response } from 'express';
import { performance } from 'perf_hooks';
interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  timestamp: string;
  uptime: number;
  version: string;
  services: {
    workers: HealthCheckResult;
    cache: HealthCheckResult;
    memory: HealthCheckResult;
    cpu: HealthCheckResult;
  };
  metrics: {
    activeRequests: number;
    totalRequests: number;
    avgResponseTime: number;
    errorRate: number;
  };
  dependencies: {
    tensorflow: HealthCheckResult;
    sharp: HealthCheckResult;
    filesystem: HealthCheckResult;
  };
}
interface HealthCheckResult {
  status: 'pass' | 'warn' | 'fail';
  message?: string;
  details?: any;
  responseTime?: number;
}
// Simple metrics tracking
let totalRequests = 0;
let totalResponseTime = 0;
let totalErrors = 0;
let activeRequests = 0;
/**
 * Update metrics tracking
 */
export function updateMetrics(responseTime: number, isError = false): void {
  totalRequests++;
  totalResponseTime += responseTime;
  if (isError) {
    totalErrors++;
  }
}
export function incrementActiveRequests(): void {
  activeRequests++;
}
export function decrementActiveRequests(): void {
  activeRequests = Math.max(0, activeRequests - 1);
}
/**
 * Check memory usage
 */
function checkMemoryHealth(): HealthCheckResult {
  try {
    const memUsage = process.memoryUsage();
    const totalMemory = require('os').totalmem();
    const usedMemoryMB = memUsage.rss / 1024 / 1024;
    const totalMemoryMB = totalMemory / 1024 / 1024;
    const memoryUsagePercent = (usedMemoryMB / totalMemoryMB) * 100;
    
    if (memoryUsagePercent > 85) {
      return {
        status: 'fail',
        message: `High memory usage: ${Math.round(memoryUsagePercent)}%`,
        details: {
          rss: Math.round(usedMemoryMB),
          heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024),
          heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024),
          external: Math.round(memUsage.external / 1024 / 1024),
          percent: Math.round(memoryUsagePercent)
        }
      };
    }
    
    if (memoryUsagePercent > 70) {
      return {
        status: 'warn',
        message: `Moderate memory usage: ${Math.round(memoryUsagePercent)}%`,
        details: {
          rss: Math.round(usedMemoryMB),
          heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024),
          heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024),
          external: Math.round(memUsage.external / 1024 / 1024),
          percent: Math.round(memoryUsagePercent)
        }
      };
    }
    
    return {
      status: 'pass',
      message: `Memory usage normal: ${Math.round(memoryUsagePercent)}%`,
      details: {
        rss: Math.round(usedMemoryMB),
        heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024),
        heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024),
        external: Math.round(memUsage.external / 1024 / 1024),
        percent: Math.round(memoryUsagePercent)
      }
    };
  } catch (error) {
    return {
      status: 'fail',
      message: `Memory check error: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}
/**
 * Check CPU usage (simplified)
 */
function checkCpuHealth(): HealthCheckResult {
  try {
    const loadAvg = require('os').loadavg();
    const cpuCount = require('os').cpus().length;
    const oneMinuteLoad = loadAvg[0];
    const loadPercent = (oneMinuteLoad / cpuCount) * 100;
    
    if (loadPercent > 90) {
      return {
        status: 'fail',
        message: `High CPU load: ${Math.round(loadPercent)}%`,
        details: { load: oneMinuteLoad, cores: cpuCount, percent: Math.round(loadPercent) }
      };
    }
    
    if (loadPercent > 70) {
      return {
        status: 'warn',
        message: `Moderate CPU load: ${Math.round(loadPercent)}%`,
        details: { load: oneMinuteLoad, cores: cpuCount, percent: Math.round(loadPercent) }
      };
    }
    
    return {
      status: 'pass',
      message: `CPU load normal: ${Math.round(loadPercent)}%`,
      details: { load: oneMinuteLoad, cores: cpuCount, percent: Math.round(loadPercent) }
    };
  } catch (error) {
    return {
      status: 'fail',
      message: `CPU check error: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}
/**
 * Check filesystem access (optimized sync operations)
 * Note: Health checks are called infrequently, sync is acceptable here
 * but we minimize I/O and use efficient operations
 */
function checkFilesystemHealth(): HealthCheckResult {
  try {
    const fs = require('fs');
    const os = require('os');
    
    // Test writing to temp directory with minimal I/O
    const testFile = `${os.tmpdir()}/health-check-${Date.now()}.tmp`;
    
    try {
      // Use minimal data for faster operation
      fs.writeFileSync(testFile, 'ok');
      fs.unlinkSync(testFile);
    } catch (writeError) {
      // Cleanup test file if write succeeded but delete failed
      try {
        fs.unlinkSync(testFile);
      } catch {
        // Ignore cleanup errors
      }
      throw writeError;
    }
    
    return {
      status: 'pass',
      message: 'Filesystem accessible',
      details: { tmpdir: os.tmpdir() }
    };
  } catch (error) {
    return {
      status: 'fail',
      message: `Filesystem error: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}
/**
 * Comprehensive health check endpoint
 */
export function healthCheck(req: Request, res: Response): void {
  const startTime = performance.now();
  
  const services = {
    memory: checkMemoryHealth(),
    cpu: checkCpuHealth()
  };
  
  const dependencies = {
    filesystem: checkFilesystemHealth()
  };
  
  // Determine overall health status
  const allChecks = [...Object.values(services), ...Object.values(dependencies)];
  const hasFailures = allChecks.some(check => check.status === 'fail');
  const hasWarnings = allChecks.some(check => check.status === 'warn');
  
  const overallStatus = hasFailures ? 'unhealthy' : 
                     hasWarnings ? 'degraded' : 'healthy';
  
  const avgResponseTime = totalRequests > 0 ? totalResponseTime / totalRequests : 0;
  const errorRate = totalRequests > 0 ? (totalErrors / totalRequests) * 100 : 0;
  
  const healthStatus: HealthStatus = {
    status: overallStatus,
    timestamp: new Date().toISOString(),
    uptime: process.uptime() * 1000,
    version: process.env.npm_package_version || '1.0.0',
    services,
    metrics: {
      activeRequests,
      totalRequests,
      avgResponseTime: Math.round(avgResponseTime * 100) / 100,
      errorRate: Math.round(errorRate * 100) / 100
    },
    dependencies
  };
  
  const responseTime = performance.now() - startTime;
  
  // Set appropriate HTTP status code
  const statusCode = overallStatus === 'healthy' ? 200 : 
                    overallStatus === 'degraded' ? 200 : 503;
  
  res.status(statusCode).json(healthStatus);
  
  // Log health check results
  console.log(`üè• Health check completed in ${Math.round(responseTime)}ms: ${overallStatus}`);
}
/**
 * Simple readiness check for Kubernetes/container orchestration
 */
export function readinessCheck(req: Request, res: Response): void {
  // Check if essential services are ready
  const memoryReady = checkMemoryHealth().status !== 'fail';
  const filesystemReady = checkFilesystemHealth().status !== 'fail';
  
  const isReady = memoryReady && filesystemReady;
  
  if (isReady) {
    res.status(200).json({ status: 'ready' });
  } else {
    res.status(503).json({ 
      status: 'not ready',
      checks: {
        memory: memoryReady,
        filesystem: filesystemReady
      }
    });
  }
}
/**
 * Simple liveness check for container orchestration
 */
export function livenessCheck(req: Request, res: Response): void {
  // Simple check - if we can respond, we're alive
  res.status(200).json({ 
    status: 'alive',
    uptime: process.uptime(),
    pid: process.pid
  });
}