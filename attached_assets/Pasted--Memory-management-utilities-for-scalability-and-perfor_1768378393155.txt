/**
 * Memory management utilities for scalability and performance monitoring
 * Implements aggressive cleanup strategies to prevent memory leaks
 */

import { qerrors } from 'qerrors';

// Dynamic import for heapdump (optional dependency)
let heapdump: any = null;
let heapdumpLoaded = false;

async function loadHeapdump() {
  if (heapdumpLoaded) return heapdump;
  try {
    heapdump = require('heapdump');
  } catch (error) {
    // heapdump not available - will continue without heap snapshots
    console.log('[memory] heapdump not available - heap snapshots disabled');
  }
  heapdumpLoaded = true;
  return heapdump;
}

interface MemoryStats {
  heapUsed: number;
  heapTotal: number;
  external: number;
  rss: number;
  heapUsagePercent: number;
}

interface MemoryThresholds {
  warningPercent: number;
  criticalPercent: number;
  emergencyPercent: number;
  maxHeapSizeMB: number;
}

export class MemoryManager {
  private thresholds: MemoryThresholds;
  private monitoringInterval: NodeJS.Timeout | null = null;
  private gcInterval: NodeJS.Timeout | null = null;
  private lastCleanup: number = 0;
  private cleanupCooldown: number = 30000; // 30 seconds between cleanups

  constructor(thresholds?: Partial<MemoryThresholds>) {
    this.thresholds = {
      warningPercent: 70,
      criticalPercent: 85,
      emergencyPercent: 95,
      maxHeapSizeMB: 512,
      ...thresholds
    };
  }

  /**
   * Starts memory monitoring with automatic cleanup
   */
  startMonitoring(): void {
    if (this.monitoringInterval) {
      this.stopMonitoring();
    }

    // Monitor memory every 15 seconds for early detection
    this.monitoringInterval = setInterval(() => {
      this.checkMemoryUsage();
    }, 15000);

    // Schedule periodic garbage collection if available
    if ((global as any).gc) {
      this.gcInterval = setInterval(() => {
        this.performGarbageCollection();
      }, 60000); // Every minute
    }

    console.log('[memory] Memory monitoring started');
  }

  /**
   * Stops all memory monitoring intervals
   */
  stopMonitoring(): void {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = null;
    }
    if (this.gcInterval) {
      clearInterval(this.gcInterval);
      this.gcInterval = null;
    }
    console.log('[memory] Memory monitoring stopped');
  }

  /**
   * Gets current memory statistics
   */
  getCurrentStats(): MemoryStats {
    const memUsage = process.memoryUsage();
    const heapUsagePercent = memUsage.heapTotal > 0 
      ? (memUsage.heapUsed / memUsage.heapTotal) * 100 
      : 0;

    return {
      heapUsed: memUsage.heapUsed,
      heapTotal: memUsage.heapTotal,
      external: memUsage.external,
      rss: memUsage.rss,
      heapUsagePercent
    };
  }

  /**
   * Checks memory usage and triggers appropriate actions
   */
  private async checkMemoryUsage(): Promise<void> {
    const stats = this.getCurrentStats();
    const heapUsedMB = stats.heapUsed / 1024 / 1024;
    const heapTotalMB = stats.heapTotal / 1024 / 1024;

    // Log memory usage every 5 minutes
    const now = Date.now();
    if (now % 300000 < 15000 && now > 300000) { // After first 5 minutes
      console.log(`[memory] Heap: ${heapUsedMB.toFixed(2)}MB/${heapTotalMB.toFixed(2)}MB (${stats.heapUsagePercent.toFixed(2)}%)`);
    }

    // Check thresholds and take action
    if (stats.heapUsagePercent >= this.thresholds.emergencyPercent) {
      await this.handleEmergencyMemory(stats);
    } else if (stats.heapUsagePercent >= this.thresholds.criticalPercent) {
      this.handleCriticalMemory(stats);
    } else if (stats.heapUsagePercent >= this.thresholds.warningPercent) {
      this.handleWarningMemory(stats);
    }

    // Check absolute heap size limit
    if (heapUsedMB >= this.thresholds.maxHeapSizeMB) {
      await this.handleMaxHeapSizeExceeded(stats);
    }
  }

  /**
   * Handles emergency memory situations
   */
  private async handleEmergencyMemory(stats: MemoryStats): Promise<void> {
    const heapUsedMB = stats.heapUsed / 1024 / 1024;
    console.error(`[memory] EMERGENCY: High memory usage ${heapUsedMB.toFixed(2)}MB (${stats.heapUsagePercent.toFixed(2)}%)`);
    
    // Take heap snapshot for debugging
    const heapSnapshot = await this.takeHeapSnapshot('emergency');
    
    // Force immediate garbage collection
    this.performGarbageCollection();
    
    // Trigger aggressive cleanup
    await this.performAggressiveCleanup();
    
    // Log for monitoring
    qerrors(new Error('Emergency memory threshold exceeded'), 'memory.emergency', {
      heapUsed: heapUsedMB,
      heapUsagePercent: stats.heapUsagePercent,
      heapSnapshot
    });
  }

  /**
   * Handles critical memory situations
   */
  private handleCriticalMemory(stats: MemoryStats): void {
    const heapUsedMB = stats.heapUsed / 1024 / 1024;
    console.warn(`[memory] CRITICAL: High memory usage ${heapUsedMB.toFixed(2)}MB (${stats.heapUsagePercent.toFixed(2)}%)`);
    
    // Force garbage collection
    this.performGarbageCollection();
    
    // Trigger moderate cleanup
    this.performModerateCleanup();
  }

  /**
   * Handles warning memory situations
   */
  private handleWarningMemory(stats: MemoryStats): void {
    const heapUsedMB = stats.heapUsed / 1024 / 1024;
    console.warn(`[memory] WARNING: Elevated memory usage ${heapUsedMB.toFixed(2)}MB (${stats.heapUsagePercent.toFixed(2)}%)`);
    
    // Suggest garbage collection
    this.performGarbageCollection();
  }

  /**
   * Handles maximum heap size exceeded
   */
  private async handleMaxHeapSizeExceeded(stats: MemoryStats): Promise<void> {
    const heapUsedMB = stats.heapUsed / 1024 / 1024;
    console.error(`[memory] MAX HEAP EXCEEDED: ${heapUsedMB.toFixed(2)}MB > ${this.thresholds.maxHeapSizeMB}MB`);
    
    // Take heap snapshot for debugging
    const heapSnapshot = await this.takeHeapSnapshot('max-heap-exceeded');
    
    // Force garbage collection
    this.performGarbageCollection();
    
    // Perform most aggressive cleanup
    await this.performAggressiveCleanup();
    
    // Log critical error
    qerrors(new Error('Maximum heap size exceeded'), 'memory.maxHeapExceeded', {
      heapUsed: heapUsedMB,
      maxHeapSize: this.thresholds.maxHeapSizeMB,
      heapSnapshot
    });
  }

  /**
   * Performs garbage collection if available
   */
  private performGarbageCollection(): void {
    if ((global as any).gc) {
      try {
        (global as any).gc();
        console.log('[memory] Forced garbage collection completed');
      } catch (error) {
        qerrors(error as Error, 'memory.gcFailed');
      }
    }
  }

  /**
   * Takes heap snapshot if heapdump is available
   */
  async takeHeapSnapshot(reason?: string): Promise<string | null> {
    await loadHeapdump();
    if (!heapdump) {
      console.log('[memory] heapdump not available - cannot take heap snapshot');
      return null;
    }

    try {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const reasonSuffix = reason ? `-${reason}` : '';
      const filename = `heapdump-${timestamp}${reasonSuffix}.heapsnapshot`;
      
      return new Promise((resolve, reject) => {
        heapdump.writeSnapshot(filename, (err: Error | null, filename: string) => {
          if (err) {
            qerrors(err, 'memory.heapdumpFailed');
            console.error('[memory] Failed to write heap snapshot:', err.message);
            reject(err);
          } else {
            console.log(`[memory] Heap snapshot written to: ${filename}`);
            resolve(filename);
          }
        });
      });
    } catch (error) {
      qerrors(error as Error, 'memory.heapdumpError');
      console.error('[memory] Error taking heap snapshot:', error);
      return null;
    }
  }

  /**
   * Performs aggressive memory cleanup
   */
  private async performAggressiveCleanup(): Promise<void> {
    const now = Date.now();
    
    // Prevent too frequent cleanups
    if (now - this.lastCleanup < this.cleanupCooldown) {
      return;
    }
    
    this.lastCleanup = now;
    
    try {
      // SCALABILITY FIX: Use async/await with proper delays instead of busy-wait loops
      // Force garbage collection multiple times with proper async delays
      for (let i = 0; i < 3; i++) {
        this.performGarbageCollection();
        // Use async delay instead of blocking busy-wait
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      console.log('[memory] Aggressive cleanup completed');
    } catch (error) {
      qerrors(error as Error, 'memory.aggressiveCleanupFailed');
    }
  }

  /**
   * Performs moderate memory cleanup
   */
  private performModerateCleanup(): void {
    const now = Date.now();
    
    // Prevent too frequent cleanups
    if (now - this.lastCleanup < this.cleanupCooldown) {
      return;
    }
    
    this.lastCleanup = now;
    
    try {
      // Force garbage collection
      this.performGarbageCollection();
      
      console.log('[memory] Moderate cleanup completed');
    } catch (error) {
      qerrors(error as Error, 'memory.moderateCleanupFailed');
    }
  }

  /**
   * Gets memory health status
   */
  getHealthStatus(): {
    status: 'healthy' | 'warning' | 'critical' | 'emergency';
    stats: MemoryStats;
    thresholds: MemoryThresholds;
  } {
    const stats = this.getCurrentStats();
    
    let status: 'healthy' | 'warning' | 'critical' | 'emergency' = 'healthy';
    
    if (stats.heapUsagePercent >= this.thresholds.emergencyPercent) {
      status = 'emergency';
    } else if (stats.heapUsagePercent >= this.thresholds.criticalPercent) {
      status = 'critical';
    } else if (stats.heapUsagePercent >= this.thresholds.warningPercent) {
      status = 'warning';
    }
    
    return {
      status,
      stats,
      thresholds: this.thresholds
    };
  }

  /**
   * Cleanup method for graceful shutdown
   */
  cleanup(): void {
    this.stopMonitoring();
    console.log('[memory] Memory manager cleaned up');
  }

  /**
   * Gets heapdump availability status
   */
  async isHeapdumpAvailable(): Promise<boolean> {
    await loadHeapdump();
    return heapdump !== null;
  }

  /**
   * Manually trigger heap snapshot with custom filename
   */
  async createManualHeapSnapshot(label: string = 'manual'): Promise<string | null> {
    console.log(`[memory] Creating manual heap snapshot: ${label}`);
    return await this.takeHeapSnapshot(label);
  }
}

// SCALABILITY FIX: Balanced memory manager for optimal performance
export const memoryManager = new MemoryManager({
  warningPercent: 80,      // Higher warning threshold to reduce unnecessary cleanup
  criticalPercent: 90,     // Higher critical threshold for better performance
  emergencyPercent: 95,   // Emergency threshold for immediate action
  maxHeapSizeMB: 1024     // Increased max heap size for better cache efficiency
});