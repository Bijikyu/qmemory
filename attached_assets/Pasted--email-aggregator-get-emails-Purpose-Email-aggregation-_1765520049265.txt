@email-aggregator/get-emails
Purpose: Email aggregation utility that combines and deduplicates contacts from multiple discovery sources. Explanation:
This utility addresses the common need to aggregate email contacts from various discovery mechanisms (site scraping, WHOIS lookup, etc.) while maintaining provenance information and deduplicating results. It provides a unified interface for combining different email sources and handling errors gracefully.

This is valuable for lead generation systems, contact discovery tools, and any application that needs to consolidate contact information from multiple sources while maintaining data quality and source attribution.

import type { GetDomainResult } from "./getDomain.js";
import type { SiteEmailsResult } from "./siteEmails.js";
import type { WhoisEmailResult } from "./whoisEmail.js";
/** Contact detail plus provenance for downstream auditing. */
export interface EmailTarget {
  email: string; // Email address
  source: "site" | "whois"; // Originating discovery channel
}
/** Input payload for getEmails. */
export interface GetEmailsData {
  linkedUrl: string; // URL whose domain should be scanned for contacts
}
/** Result payload from getEmails. */
export interface GetEmailsResult {
  domain: string | null; // Normalized domain for downstream usage
  emails: EmailTarget[]; // Contact cards discovered across strategies
  errors?: string[]; // Aggregated soft failures
}
/** Aggregation inputs supplied to the pure getEmails helper. */
export interface GetEmailsAggregation {
  domainResult: GetDomainResult; // Result from getDomain helper
  siteResult?: SiteEmailsResult; // Precomputed site scraping outcome
  whoisResult?: WhoisEmailResult; // Precomputed WHOIS lookup outcome
  additionalErrors?: string[]; // Any extra orchestration errors to include
}
/**
 * Aggregates all discoverable contact emails from supplied lookup results.
 * @param aggregation Precomputed domain, site scrape, and WHOIS results.
 * @returns Aggregated result object with deduped contacts and any non-fatal errors.
 */
import { dedupeByLowercaseFirst } from "./dedupe.js";
export function getEmails(aggregation: GetEmailsAggregation): GetEmailsResult {
  const collected: EmailTarget[] = []; // gather all sources, dedupe after to preserve first-seen precedence
  const errors: string[] = []; // collect recoverable issues so callers see soft failures without throwing
  const domainResult = aggregation.domainResult; // upstream normalization outcome
  const domain = domainResult.domain ?? null; // explicit null keeps API contracts stable
  if (domainResult.error) errors.push(domainResult.error);
  if (aggregation.siteResult) {
    aggregation.siteResult.emails.forEach(contact => collected.push(contact));
    if (aggregation.siteResult.error) errors.push(aggregation.siteResult.error); // bubble up scrape issues
  }
  if (aggregation.whoisResult) {
    const whoisEmail = aggregation.whoisResult.email;
    if (whoisEmail) collected.push(whoisEmail);
    if (aggregation.whoisResult.error) errors.push(aggregation.whoisResult.error); // include WHOIS lookup warnings
  }
  if (aggregation.additionalErrors?.length) {
    // Rationale: callers may surface soft failures (timeouts, skips). We merge
    // them here so consumers see a single, consolidated error list.
    errors.push(...aggregation.additionalErrors); // merge orchestrator-provided errors for full transparency
  }
  return {
    domain, // reflect resolved domain (nullable when parsing failed)
    emails: dedupeByLowercaseFirst(collected, c => c.email), // keep first-seen by email
    errors: errors.length ? errors : undefined, // omit when empty to keep payload tidy
  };
}