Memory/Database
@scrooge/test-memory-manager
Purpose: Advanced memory management utilities specifically designed for test environments to prevent leaks and ensure reliability. Explanation:
This module combines memory monitoring, cleanup, and tracking capabilities specifically optimized for testing environments. It solves the critical problem of memory leaks in test suites that can cause flaky tests, CI failures, and unreliable test results. This would be reused across any Node.js testing environment where memory management is critical, particularly in large test suites, integration tests, and CI/CD pipelines.

The module provides automatic memory tracking, cleanup scheduling, and detailed reporting specifically for test scenarios. It handles edge cases like garbage collection availability, different Node.js versions, and provides comprehensive leak detection algorithms.

/**
 * Test Memory Manager
 * Advanced memory management for test environments
 */
import { performance } from 'perf_hooks';
interface MemoryCheckpoint {
  id: string;
  timestamp: number;
  heapUsed: number;
  heapTotal: number;
  external: number;
  rss: number;
  arrayBuffers?: number;
  context?: string;
}
interface MemoryLeakReport {
  detected: boolean;
  checkpoints: MemoryCheckpoint[];
  analysis: {
    heapGrowth: number;
    rssGrowth: number;
    externalGrowth: number;
    averageGrowthRate: number;
    suspiciousPatterns: string[];
  };
  recommendations: string[];
}
export class TestMemoryManager {
  private checkpoints: MemoryCheckpoint[] = [];
  private isActive: boolean = false;
  private gcAvailable: boolean = false;
  private leakThresholds = {
    heap: 50, // MB
    rss: 100, // MB
    external: 25, // MB
    growthRate: 5 // MB per minute
  };
  constructor() {
    this.gcAvailable = typeof global.gc === 'function';
  }
  /**
   * Start memory monitoring session
   */
  public startMonitoring(context?: string): void {
    if (this.isActive) {
      console.warn('Memory monitoring already active');
      return;
    }
    this.isActive = true;
    this.checkpoints = [];
    
    // Take initial baseline checkpoint
    this.takeCheckpoint('baseline', context);
    
    console.log(`ðŸ§  Memory monitoring started ${context ? `for ${context}` : ''}`);
  }
  /**
   * Stop memory monitoring and generate report
   */
  public stopMonitoring(): MemoryLeakReport {
    if (!this.isActive) {
      console.warn('Memory monitoring not active');
      return this.generateEmptyReport();
    }
    // Take final checkpoint
    this.takeCheckpoint('final');
    this.isActive = false;
    const report = this.analyzeMemoryLeaks();
    
    console.log(`ðŸ§  Memory monitoring stopped`);
    this.printReport(report);
    
    return report;
  }
  /**
   * Take memory checkpoint
   */
  public takeCheckpoint(id: string, context?: string): MemoryCheckpoint {
    if (!this.isActive) {
      throw new Error('Memory monitoring not active');
    }
    const usage = process.memoryUsage();
    const checkpoint: MemoryCheckpoint = {
      id,
      timestamp: performance.now(),
      heapUsed: Math.round(usage.heapUsed / 1024 / 1024),
      heapTotal: Math.round(usage.heapTotal / 1024 / 1024),
      external: Math.round(usage.external / 1024 / 1024),
      rss: Math.round(usage.rss / 1024 / 1024),
      arrayBuffers: usage.arrayBuffers ? Math.round(usage.arrayBuffers / 1024 / 1024) : undefined,
      context
    };
    this.checkpoints.push(checkpoint);
    
    // Keep only recent checkpoints
    if (this.checkpoints.length > 20) {
      this.checkpoints.shift();
    }
    return checkpoint;
  }
  /**
   * Force garbage collection if available
   */
  public forceGarbageCollection(): boolean {
    if (!this.gcAvailable) {
      console.warn('Garbage collection not available');
      return false;
    }
    // Run GC multiple times with small delays
    for (let i = 0; i < 3; i++) {
      global.gc();
      // Small delay to allow GC to complete
      const start = Date.now();
      while (Date.now() - start < 10) {
        // Busy wait for very short delay
      }
    }
    return true;
  }
  /**
   * Get current memory usage
   */
  public getCurrentUsage(): MemoryCheckpoint {
    const usage = process.memoryUsage();
    return {
      id: 'current',
      timestamp: performance.now(),
      heapUsed: Math.round(usage.heapUsed / 1024 / 1024),
      heapTotal: Math.round(usage.heapTotal / 1024 / 1024),
      external: Math.round(usage.external / 1024 / 1024),
      rss: Math.round(usage.rss / 1024 / 1024),
      arrayBuffers: usage.arrayBuffers ? Math.round(usage.arrayBuffers / 1024 / 1024) : undefined
    };
  }
  /**
   * Cleanup memory aggressively
   */
  public async cleanup(): Promise<void> {
    console.log('ðŸ§¹ Starting aggressive memory cleanup...');
    
    // Clear global references
    this.clearGlobalReferences();
    
    // Force garbage collection
    this.forceGarbageCollection();
    
    // Allow some time for cleanup to complete
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Take checkpoint after cleanup
    this.takeCheckpoint('cleanup');
    
    console.log('âœ… Memory cleanup completed');
  }
  /**
   * Analyze memory leaks from checkpoints
   */
  private analyzeMemoryLeaks(): MemoryLeakReport {
    if (this.checkpoints.length < 3) {
      return this.generateEmptyReport();
    }
    const baseline = this.checkpoints[0];
    const recent = this.checkpoints.slice(-3);
    const final = this.checkpoints[this.checkpoints.length - 1];
    // Calculate growth
    const heapGrowth = final.heapUsed - baseline.heapUsed;
    const rssGrowth = final.rss - baseline.rss;
    const externalGrowth = final.external - baseline.external;
    // Calculate growth rate (MB per minute)
    const duration = (final.timestamp - baseline.timestamp) / 1000 / 60; // minutes
    const averageGrowthRate = duration > 0 ? (heapGrowth + rssGrowth) / 2 / duration : 0;
    // Check for suspicious patterns
    const suspiciousPatterns: string[] = [];
    
    if (heapGrowth > this.leakThresholds.heap) {
      suspiciousPatterns.push('Heap memory exceeds threshold');
    }
    
    if (rssGrowth > this.leakThresholds.rss) {
      suspiciousPatterns.push('RSS memory exceeds threshold');
    }
    
    if (externalGrowth > this.leakThresholds.external) {
      suspiciousPatterns.push('External memory exceeds threshold');
    }
    
    if (averageGrowthRate > this.leakThresholds.growthRate) {
      suspiciousPatterns.push('High memory growth rate detected');
    }
    // Check for monotonic growth (always increasing)
    if (this.isMonotonicGrowth(recent)) {
      suspiciousPatterns.push('Monotonic memory growth pattern');
    }
    const detected = suspiciousPatterns.length > 0 || 
                   heapGrowth > 0 || 
                   rssGrowth > 0 ||
                   externalGrowth > 0;
    return {
      detected,
      checkpoints: this.checkpoints,
      analysis: {
        heapGrowth,
        rssGrowth,
        externalGrowth,
        averageGrowthRate,
        suspiciousPatterns
      },
      recommendations: this.generateRecommendations(detected, suspiciousPatterns, this.analysis)
    };
  }
  /**
   * Check for monotonic growth pattern
   */
  private isMonotonicGrowth(checkpoints: MemoryCheckpoint[]): boolean {
    if (checkpoints.length < 3) return false;
    for (let i = 1; i < checkpoints.length; i++) {
      if (checkpoints[i].heapUsed < checkpoints[i - 1].heapUsed ||
          checkpoints[i].rss < checkpoints[i - 1].rss) {
        return false;
      }
    }
    
    return true;
  }
  /**
   * Generate recommendations based on analysis
   */
  private generateRecommendations(
    detected: boolean,
    patterns: string[],
    analysis: MemoryLeakReport['analysis']
  ): string[] {
    const recommendations: string[] = [];
    if (!detected) {
      recommendations.push('âœ… No memory leaks detected');
      return recommendations;
    }
    if (analysis.heapGrowth > this.leakThresholds.heap) {
      recommendations.push('Consider increasing heap memory limits');
      recommendations.push('Check for large object allocations');
    }
    if (analysis.averageGrowthRate > this.leakThresholds.growthRate) {
      recommendations.push('Implement more frequent garbage collection');
      recommendations.push('Review object lifecycle management');
    }
    if (patterns.includes('Monotonic memory growth pattern')) {
      recommendations.push('Investigate event listeners and timers');
      recommendations.push('Check for circular references');
      recommendations.push('Review cache management');
    }
    recommendations.push('Run with --inspect to identify memory hotspots');
    recommendations.push('Consider using heap snapshot analysis');
    recommendations.push('Review third-party library usage');
    return recommendations;
  }
  /**
   * Clear common global references that might hold memory
   */
  private clearGlobalReferences(): void {
    const refsToClear = [
      'testServer',
      'mongoConnection',
      '__MONGO_DB__',
      '__MONGOD__',
      'app',
      'server',
      'io',
      'redisClient',
      'cache',
      'timers'
    ];
    refsToClear.forEach(ref => {
      if (global[ref]) {
        try {
          // Clear connections if they have close method
          if (typeof global[ref].close === 'function') {
            global[ref].close();
          }
          if (typeof global[ref].disconnect === 'function') {
            global[ref].disconnect();
          }
          if (typeof global[ref].clear === 'function') {
            global[ref].clear();
          }
        } catch (error) {
          console.warn(`Failed to clear ${ref}:`, error);
        }
        
        global[ref] = null;
        delete global[ref];
      }
    });
  }
  /**
   * Print memory report
   */
  private printReport(report: MemoryLeakReport): void {
    console.log('\nðŸ“Š Memory Leak Analysis Report:');
    console.log('=====================================');
    
    if (report.detected) {
      console.log('ðŸš¨ MEMORY LEAKS DETECTED');
    } else {
      console.log('âœ… No significant memory leaks detected');
    }
    console.log('\nðŸ“ˆ Growth Analysis:');
    console.log(`   Heap Growth: ${report.analysis.heapGrowth > 0 ? '+' : ''}${report.analysis.heapGrowth}MB`);
    console.log(`   RSS Growth: ${report.analysis.rssGrowth > 0 ? '+' : ''}${report.analysis.rssGrowth}MB`);
    console.log(`   External Growth: ${report.analysis.externalGrowth > 0 ? '+' : ''}${report.analysis.externalGrowth}MB`);
    console.log(`   Growth Rate: ${report.analysis.averageGrowthRate.toFixed(2)}MB/min`);
    if (report.analysis.suspiciousPatterns.length > 0) {
      console.log('\nâš ï¸  Suspicious Patterns:');
      report.analysis.suspiciousPatterns.forEach(pattern => {
        console.log(`   - ${pattern}`);
      });
    }
    if (report.recommendations.length > 0) {
      console.log('\nðŸ’¡ Recommendations:');
      report.recommendations.forEach(rec => {
        console.log(`   ${rec}`);
      });
    }
    console.log('=====================================\n');
  }
  /**
   * Generate empty report
   */
  private generateEmptyReport(): MemoryLeakReport {
    return {
      detected: false,
      checkpoints: [],
      analysis: {
        heapGrowth: 0,
        rssGrowth: 0,
        externalGrowth: 0,
        averageGrowthRate: 0,
        suspiciousPatterns: []
      },
      recommendations: ['âœ… Insufficient data for analysis']
    };
  }
  /**
   * Get memory manager statistics
   */
  public getStats(): {
    isActive: boolean;
    checkpointsCount: number;
    gcAvailable: boolean;
    currentUsage: MemoryCheckpoint;
  } {
    return {
      isActive: this.isActive,
      checkpointsCount: this.checkpoints.length,
      gcAvailable: this.gcAvailable,
      currentUsage: this.getCurrentUsage()
    };
  }
  /**
   * Reset memory manager
   */
  public reset(): void {
    this.isActive = false;
    this.checkpoints = [];
    console.log('ðŸ”„ Memory manager reset');
  }
}
// Factory functions for common use cases
export const createMemoryManager = () => new TestMemoryManager();
export const createLeakDetectionSession = (context?: string) => {
  const manager = new TestMemoryManager();
  manager.startMonitoring(context);
  return manager;
};
// Convenience functions for quick usage
export const quickMemoryCheck = () => {
  const manager = new TestMemoryManager();
  const before = manager.getCurrentUsage();
  manager.forceGarbageCollection();
  const after = manager.getCurrentUsage();
  
  return {
    before,
    after,
    freed: {
      heap: before.heapUsed - after.heapUsed,
      rss: before.rss - after.rss,
      external: before.external - after.external
    }
  };
};
export default TestMemoryManager;