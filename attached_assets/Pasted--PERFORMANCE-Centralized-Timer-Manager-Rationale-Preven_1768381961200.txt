/**
 * ðŸš€ PERFORMANCE: Centralized Timer Manager
 * Rationale: Prevents memory leaks from unmanaged setTimeout/setInterval calls
 * by tracking all timers and providing automatic cleanup capabilities
 */

import * as localVars from '../../config/localVars.js';

interface TimerInfo {
  id: NodeJS.Timeout;
  type: 'timeout' | 'interval';
  createdAt: number;
  source: string;
  cleanupOnShutdown?: boolean;
}

interface TimerStats {
  total: number;
  timeouts: number;
  intervals: number;
  bySource: Record<string, number>;
}

/**
 * Manages all setTimeout/setInterval calls to prevent memory leaks
 */
export class TimerManager {
  private timers: Map<NodeJS.Timeout, TimerInfo> = new Map();
  private isShutdown = false;
  private stats: TimerStats = {
    total: 0,
    timeouts: 0,
    intervals: 0,
    bySource: {}
  };

  /**
   * Create a managed setTimeout
   * @param callback Function to execute
   * @param delay Delay in milliseconds
   * @param source Source identifier for debugging
   * @param cleanupOnShutdown Whether to auto-cleanup on shutdown
   * @returns Timer ID
   */
  setTimeout(
    callback: (...args: any[]) => void,
    delay: number,
    source: string = 'unknown',
    cleanupOnShutdown: boolean = true
  ): NodeJS.Timeout {
    const shouldTrack = !this.isShutdown;
    if (this.isShutdown) {
      console.warn(`TimerManager: Cannot create setTimeout after shutdown (source: ${source})`);
    }

    const timerId = setTimeout(() => {
      this.removeTimer(timerId);
      try {
        callback();
      } catch (error) {
        console.error(`TimerManager: Error in timeout callback (source: ${source}):`, error);
      }
    }, delay);

    const timerInfo: TimerInfo = {
      id: timerId,
      type: 'timeout',
      createdAt: Date.now(),
      source,
      cleanupOnShutdown
    };

    this.timers.set(timerId, timerInfo);
    if (shouldTrack) {
      this.updateStats('add', timerInfo);
    }

    return timerId;
  }

  /**
   * Create a managed setInterval
   * @param callback Function to execute
   * @param delay Delay in milliseconds
   * @param source Source identifier for debugging
   * @param cleanupOnShutdown Whether to auto-cleanup on shutdown
   * @returns Timer ID
   */
  setInterval(
    callback: (...args: any[]) => void,
    delay: number,
    source: string = 'unknown',
    cleanupOnShutdown: boolean = true
  ): NodeJS.Timeout {
    const shouldTrack = !this.isShutdown;
    if (this.isShutdown) {
      console.warn(`TimerManager: Cannot create setInterval after shutdown (source: ${source})`);
    }

    const timerId = setInterval(() => {
      try {
        callback();
      } catch (error) {
        console.error(`TimerManager: Error in interval callback (source: ${source}):`, error);
      }
    }, delay);

    const timerInfo: TimerInfo = {
      id: timerId,
      type: 'interval',
      createdAt: Date.now(),
      source,
      cleanupOnShutdown
    };

    this.timers.set(timerId, timerInfo);
    if (shouldTrack) {
      this.updateStats('add', timerInfo);
    }

    return timerId;
  }

  /**
   * Clear a managed timeout
   * @param timerId Timer ID to clear
   */
  clearTimeout(timerId: NodeJS.Timeout): void {
    if (timerId) {
      global.clearTimeout(timerId);
      this.removeTimer(timerId);
    }
  }

  /**
   * Clear a managed interval
   * @param timerId Timer ID to clear
   */
  clearInterval(timerId: NodeJS.Timeout): void {
    if (timerId) {
      global.clearInterval(timerId);
      this.removeTimer(timerId);
    }
  }

  /**
   * Remove timer from tracking
   * @param timerIdString Timer ID as string
   */
  private removeTimer(timerId: NodeJS.Timeout): void {
    const timerInfo = this.timers.get(timerId);
    if (timerInfo) {
      this.updateStats('remove', timerInfo);
      this.timers.delete(timerId);
    }
  }

  /**
   * Update internal statistics
   */
  private updateStats(action: 'add' | 'remove', timerInfo: TimerInfo): void {
    if (action === 'add') {
      this.stats.total++;
      this.stats.bySource[timerInfo.source] = (this.stats.bySource[timerInfo.source] || 0) + 1;
      
      if (timerInfo.type === 'timeout') {
        this.stats.timeouts++;
      } else {
        this.stats.intervals++;
      }
    } else {
      this.stats.total = Math.max(0, this.stats.total - 1);
      this.stats.bySource[timerInfo.source] = Math.max(0, (this.stats.bySource[timerInfo.source] || 0) - 1);
      
      if (timerInfo.type === 'timeout') {
        this.stats.timeouts = Math.max(0, this.stats.timeouts - 1);
      } else {
        this.stats.intervals = Math.max(0, this.stats.intervals - 1);
      }
    }
  }

  /**
   * Get current timer statistics
   */
  getStats(): TimerStats {
    return { ...this.stats };
  }

  /**
   * Get all active timer information
   */
  getActiveTimers(): TimerInfo[] {
    return Array.from(this.timers.values());
  }

  /**
   * Get timer entry by timer object
   * @param timerId Timer object
   */
  private getTimerInfo(timerId: NodeJS.Timeout): TimerInfo | undefined {
    return this.timers.get(timerId);
  }

  /**
   * Check for potential memory leaks (timers older than threshold)
   * @param maxAge Maximum age in milliseconds
   */
  detectMemoryLeaks(maxAge: number = 300000): { source: string; age: number; type: string }[] {
    const now = Date.now();
    const leaks: { source: string; age: number; type: string }[] = [];

    for (const timerInfo of this.timers.values()) {
      const age = now - timerInfo.createdAt;
      if (age > maxAge) {
        leaks.push({
          source: timerInfo.source,
          age,
          type: timerInfo.type
        });
      }
    }

    return leaks;
  }

  /**
   * Clear all timers from a specific source
   * @param source Source identifier
   */
  clearBySource(source: string): number {
    let cleared = 0;
    const timersToClear: NodeJS.Timeout[] = [];

    for (const [timerId, timerInfo] of this.timers.entries()) {
      if (timerInfo.source === source) {
        timersToClear.push(timerId);
      }
    }

    for (const timerId of timersToClear) {
      const timerInfo = this.timers.get(timerId);
      if (timerInfo) {
        if (timerInfo.type === 'timeout') {
          this.clearTimeout(timerId);
        } else {
          this.clearInterval(timerId);
        }
        cleared++;
      }
    }

    return cleared;
  }

  /**
   * Shutdown timer manager and clean up all timers
   */
  shutdown(): void {
    if (this.isShutdown) return;
    
    this.isShutdown = true;
    
    for (const [timerIdString, timerInfo] of this.timers.entries()) {
      if (timerInfo.cleanupOnShutdown !== false) {
        try {
          if (timerInfo.type === 'timeout') {
            clearTimeout(timerInfo.id);
          } else {
            clearInterval(timerInfo.id);
          }
        } catch (error) {
          console.warn(`TimerManager: Error clearing timer ${timerIdString}:`, error);
        }
      }
    }

    const clearedCount = this.timers.size;
    this.timers.clear();
    
    // Reset stats
    this.stats = {
      total: 0,
      timeouts: 0,
      intervals: 0,
      bySource: {}
    };

    console.log(`TimerManager: Shutdown complete, cleared ${clearedCount} timers`);
  }

  /**
   * Force cleanup of all timers (emergency use only)
   */
  emergencyCleanup(): void {
    console.warn('TimerManager: Emergency cleanup activated - clearing all timers');
    this.isShutdown = false;
    
    for (const [timerIdString, timerInfo] of this.timers.entries()) {
      try {
        if (timerInfo.type === 'timeout') {
          clearTimeout(timerInfo.id);
        } else {
          clearInterval(timerInfo.id);
        }
      } catch (error) {
        console.warn(`TimerManager: Error during emergency cleanup of timer ${timerIdString}:`, error);
      }
    }

    this.timers.clear();
    this.stats = {
      total: 0,
      timeouts: 0,
      intervals: 0,
      bySource: {}
    };
  }
}

// Global singleton instance
export const timerManager = new TimerManager();

// Cleanup on process exit
if (typeof process !== 'undefined') {
  process.on('exit', () => {
    timerManager.shutdown();
  });

  process.on('SIGINT', () => {
    timerManager.shutdown();
    process.exit(0);
  });

  process.on('SIGTERM', () => {
    timerManager.shutdown();
    process.exit(0);
  });
}