@oakenshield/database-connection-pool
Purpose: A scalable database connection pool manager supporting multiple database types.

Explanation:
This database connection pool provides efficient connection management across multiple database types (Redis, PostgreSQL, MySQL, MongoDB) with health monitoring and automatic recovery. It solves the problem of connection overhead and resource management in database-driven applications. The pool supports dynamic sizing, query timeouts, retry logic, and comprehensive statistics. It's broadly applicable across any application that interacts with databases, providing a unified interface regardless of the underlying database technology.

// Database Connection Pool Manager
// Provides scalable database connection management with proper pooling and health monitoring
interface DatabaseConnection {
  client: any;
  createdAt: number;
  lastUsed: number;
  isHealthy: boolean;
  queryCount: number;
  isInUse: boolean;
}
interface DatabasePoolConfig {
  maxConnections: number;
  minConnections: number;
  acquireTimeout: number;
  idleTimeout: number;
  healthCheckInterval: number;
  maxQueryTime: number;
  retryAttempts: number;
  retryDelay: number;
}
class SimpleDatabasePool {
  private connections: DatabaseConnection[] = [];
  private waitingQueue: Array<{
    resolve: (connection: DatabaseConnection) => void;
    reject: (error: Error) => void;
    timestamp: number;
    timeoutHandle?: NodeJS.Timeout;
  }> = [];
  private config: DatabasePoolConfig;
  private databaseUrl: string;
  private dbType: string;
  private healthCheckInterval?: NodeJS.Timeout;
  constructor(databaseUrl: string, config: Partial<DatabasePoolConfig> = {}) {
    this.databaseUrl = databaseUrl;
    this.dbType = this.getDatabaseType(databaseUrl);
    this.config = {
      maxConnections: 20,
      minConnections: 5,
      acquireTimeout: 10000,
      idleTimeout: 300000, // 5 minutes
      healthCheckInterval: 60000, // 1 minute
      maxQueryTime: 30000, // 30 seconds
      retryAttempts: 3,
      retryDelay: 1000,
      ...config
    };
  }
  async initialize(): Promise<void> {
    // Create minimum connections
    const initPromises = [];
    for (let i = 0; i < this.config.minConnections; i++) {
      initPromises.push(this.createConnection());
    }
    
    await Promise.allSettled(initPromises);
    this.startHealthMonitoring();
  }
  private async createConnection(): Promise<DatabaseConnection> {
    try {
      const client = await this.createDatabaseClient();
      
      const connection: DatabaseConnection = {
        client,
        createdAt: Date.now(),
        lastUsed: Date.now(),
        isHealthy: true,
        queryCount: 0,
        isInUse: false
      };
      
      this.connections.push(connection);
      return connection;
    } catch (error) {
      throw error;
    }
  }
  private async createDatabaseClient(): Promise<any> {
    switch (this.dbType) {
      case 'redis': {
        const Redis = await import('redis');
        const client = Redis.createClient({
          url: this.databaseUrl,
          socket: {
            connectTimeout: 10000,
            lazyConnect: true
          }
        });
        await client.connect();
        return client;
      }
      case 'postgresql': {
        const { Pool: PgPool } = await import('pg');
        const pool = new PgPool({
          connectionString: this.databaseUrl,
          max: 1,
          idleTimeoutMillis: 300000,
          connectionTimeoutMillis: 10000
        });
        return pool;
      }
      case 'mysql': {
        const mysql = await import('mysql2/promise');
        return await mysql.createConnection({
          uri: this.databaseUrl,
          connectTimeout: 10000,
          acquireTimeout: 10000
        });
      }
      case 'mongodb': {
        const { MongoClient } = await import('mongodb');
        return await MongoClient.connect(this.databaseUrl, {
          maxPoolSize: 1,
          serverSelectionTimeoutMS: 10000,
          socketTimeoutMS: 30000
        });
      }
      default:
        throw new Error(`Unsupported database type: ${this.dbType}`);
    }
  }
  async acquireConnection(): Promise<DatabaseConnection> {
    // Optimize connection search with early exit
    const now = Date.now();
    let connection: DatabaseConnection | null = null;
    
    // Single pass through connections to find available (early exit)
    for (let i = 0; i < this.connections.length; i++) {
      const conn = this.connections[i];
      if (!conn.isInUse && conn.isHealthy) {
        connection = conn;
        break; // Found available connection, exit early
      }
    }
    
    if (connection) {
      connection.isInUse = true;
      connection.lastUsed = now;
      connection.queryCount++;
      return connection;
    }
    // If no available connection and we can create more
    if (this.connections.length < this.config.maxConnections) {
      try {
        connection = await this.createConnection();
        connection.isInUse = true;
        connection.queryCount++;
        return connection;
      } catch (error) {
        // If creation fails, continue to wait
      }
    }
    // Optimized waiting queue with timeout handling
    return new Promise((resolve, reject) => {
      const timeoutHandle = setTimeout(() => {
        const index = this.waitingQueue.findIndex(item => item.resolve === resolve);
        if (index !== -1) {
          this.waitingQueue.splice(index, 1);
        }
        reject(new Error('Connection acquire timeout'));
      }, this.config.acquireTimeout);
      this.waitingQueue.push({
        resolve,
        reject,
        timestamp: now,
        timeoutHandle
      });
    });
  }
  async releaseConnection(connection: DatabaseConnection): Promise<void> {
    connection.isInUse = false;
    connection.lastUsed = Date.now();
    // Check if there are waiting requests
    const waiter = this.waitingQueue.shift();
    if (waiter) {
      if (waiter.timeoutHandle) {
        clearTimeout(waiter.timeoutHandle);
      }
      connection.isInUse = true;
      connection.queryCount++;
      waiter.resolve(connection);
    }
  }
  async executeQuery<T = any>(query: string | any, params?: any[]): Promise<T> {
    let attempt = 0;
    while (attempt < this.config.retryAttempts) {
      let connection: DatabaseConnection | null = null;
      
      try {
        connection = await this.acquireConnection();
        
        const startTime = Date.now();
        let result: T;
        
        switch (this.dbType) {
          case 'redis':
            if (query && typeof query === 'object' && query.method && params) {
              result = await connection.client[query.method](...params);
            } else {
              result = await connection.client[query](...(params || []));
            }
            break;
          case 'postgresql':
            result = await connection.client.query(query, params);
            break;
          case 'mysql':
            result = await connection.client.execute(query, params);
            break;
          case 'mongodb':
            result = await query; // MongoDB queries are complex objects
            break;
          default:
            throw new Error(`Unsupported database type: ${this.dbType}`);
        }
        
        const queryTime = Date.now() - startTime;
        if (queryTime > this.config.maxQueryTime) {
          // Slow query warning would go here
        }
        
        return result;
      } catch (error) {
        attempt++;
        if (attempt >= this.config.retryAttempts) {
          throw error;
        }
        
        // Wait before retry
        await new Promise(resolve => setTimeout(resolve, this.config.retryDelay * attempt));
      } finally {
        if (connection) {
          await this.releaseConnection(connection);
        }
      }
    }
    
    throw new Error(`Query failed after ${this.config.retryAttempts} attempts`);
  }
  private async validateConnection(connection: DatabaseConnection): Promise<boolean> {
    try {
      switch (this.dbType) {
        case 'redis':
          await connection.client.ping();
          break;
        case 'postgresql':
          await connection.client.query('SELECT 1');
          break;
        case 'mysql':
          await connection.client.execute('SELECT 1');
          break;
        case 'mongodb':
          await connection.client.db('admin').command({ ping: 1 });
          break;
        default:
          return false;
      }
      
      connection.isHealthy = true;
      connection.lastUsed = Date.now();
      return true;
    } catch (error) {
      connection.isHealthy = false;
      return false;
    }
  }
  private startHealthMonitoring(): void {
    this.healthCheckInterval = setInterval(async () => {
      await this.performHealthCheck();
    }, this.config.healthCheckInterval);
  }
  private async performHealthCheck(): Promise<void> {
    const now = Date.now();
    const unhealthyConnections: DatabaseConnection[] = [];
    
    for (const connection of this.connections) {
      // Check if connection is idle and old
      const isIdle = !connection.isInUse;
      const isOld = (now - connection.lastUsed) > this.config.idleTimeout;
      
      if (isIdle && isOld) {
        unhealthyConnections.push(connection);
        continue;
      }
      
      // Validate health for idle connections
      if (isIdle) {
        const isHealthy = await this.validateConnection(connection);
        if (!isHealthy) {
          unhealthyConnections.push(connection);
        }
      }
    }
    
    // Remove unhealthy connections (only if not in use)
    for (const connection of unhealthyConnections) {
      if (!connection.isInUse) {
        await this.removeConnection(connection);
      } else {
        // Mark as unhealthy but let current query finish
        connection.isHealthy = false;
      }
    }
    
    // Ensure minimum connections
    const healthyConnections = this.connections.filter(conn => conn.isHealthy);
    if (healthyConnections.length < this.config.minConnections) {
      const needed = this.config.minConnections - healthyConnections.length;
      for (let i = 0; i < needed; i++) {
        try {
          await this.createConnection();
        } catch (error) {
          break;
        }
      }
    }
  }
  private async removeConnection(connection: DatabaseConnection): Promise<void> {
    try {
      switch (this.dbType) {
        case 'redis':
          await connection.client.quit();
          break;
        case 'postgresql':
          await connection.client.end();
          break;
        case 'mysql':
          await connection.client.end();
          break;
        case 'mongodb':
          await connection.client.close();
          break;
      }
    } catch (error) {
      // Ignore cleanup errors
    }
    
    const index = this.connections.indexOf(connection);
    if (index !== -1) {
      this.connections.splice(index, 1);
    }
  }
  private getDatabaseType(databaseUrl: string): string {
    const url = databaseUrl.toLowerCase();
    if (url.startsWith('redis://') || url.startsWith('rediss://')) return 'redis';
    if (url.startsWith('postgresql://') || url.startsWith('postgres://')) return 'postgresql';
    if (url.startsWith('mysql://')) return 'mysql';
    if (url.startsWith('mongodb://') || url.startsWith('mongodb+srv://')) return 'mongodb';
    return 'generic';
  }
  getStats(): {
    active: number;
    idle: number;
    total: number;
    waiting: number;
    max: number;
    min: number;
  } {
    const active = this.connections.filter(conn => conn.isInUse).length;
    const idle = this.connections.filter(conn => !conn.isInUse).length;
    
    return {
      active,
      idle,
      total: this.connections.length,
      waiting: this.waitingQueue.length,
      max: this.config.maxConnections,
      min: this.config.minConnections
    };
  }
  async shutdown(): Promise<void> {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
    }
    // Reject all waiting requests
    for (const waiter of this.waitingQueue) {
      if (waiter.timeoutHandle) {
        clearTimeout(waiter.timeoutHandle);
      }
      waiter.reject(new Error('Database pool shutting down'));
    }
    this.waitingQueue = [];
    // Close all connections
    const closePromises = this.connections.map(conn => this.removeConnection(conn));
    await Promise.allSettled(closePromises);
    
    this.connections = [];
  }
}
class DatabaseConnectionPool {
  private pools: Map<string, SimpleDatabasePool> = new Map();
  async createPool(databaseUrl: string, config?: Partial<DatabasePoolConfig>): Promise<void> {
    if (this.pools.has(databaseUrl)) {
      return;
    }
    const pool = new SimpleDatabasePool(databaseUrl, config);
    await pool.initialize();
    this.pools.set(databaseUrl, pool);
  }
  async acquireConnection(databaseUrl: string): Promise<DatabaseConnection> {
    const pool = this.pools.get(databaseUrl);
    if (!pool) {
      throw new Error(`No pool exists for database: ${databaseUrl}`);
    }
    return await pool.acquireConnection();
  }
  async releaseConnection(databaseUrl: string, connection: DatabaseConnection): Promise<void> {
    const pool = this.pools.get(databaseUrl);
    if (!pool) {
      throw new Error(`No pool exists for database: ${databaseUrl}`);
    }
    await pool.releaseConnection(connection);
  }
  async executeQuery<T = any>(databaseUrl: string, query: any, params?: any[]): Promise<T> {
    const pool = this.pools.get(databaseUrl);
    if (!pool) {
      throw new Error(`No pool exists for database: ${databaseUrl}`);
    }
    return await pool.executeQuery<T>(query, params);
  }
  getPoolStats(): Record<string, any> {
    const stats: Record<string, any> = {};
    this.pools.forEach((pool, databaseUrl) => {
      stats[databaseUrl] = pool.getStats();
    });
    return stats;
  }
  async shutdown(): Promise<void> {
    const poolValues: SimpleDatabasePool[] = [];
    this.pools.forEach(pool => poolValues.push(pool));
    const shutdownPromises = poolValues.map(pool => pool.shutdown());
    await Promise.allSettled(shutdownPromises);
    this.pools.clear();
  }
}
// Singleton instance for application
export const databaseConnectionPool = new DatabaseConnectionPool();
// Export convenience functions
export const createDatabasePool = (databaseUrl: string, config?: Partial<DatabasePoolConfig>) =>
  databaseConnectionPool.createPool(databaseUrl, config);
export const acquireDatabaseConnection = (databaseUrl: string) =>
  databaseConnectionPool.acquireConnection(databaseUrl);
export const releaseDatabaseConnection = (databaseUrl: string, connection: DatabaseConnection) =>
  databaseConnectionPool.releaseConnection(databaseUrl, connection);
export const executeDatabaseQuery = <T = any>(databaseUrl: string, query: any, params?: any[]) =>
  databaseConnectionPool.executeQuery<T>(databaseUrl, query, params);
export const getDatabasePoolStats = () => databaseConnectionPool.getPoolStats();
export const shutdownDatabaseConnectionPool = () => databaseConnectionPool.shutdown();