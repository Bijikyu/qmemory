<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>QMemory Library - Interactive Demo</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        line-height: 1.6;
        color: #333;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      header {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 30px;
        margin-bottom: 30px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      h1 {
        color: #4a5568;
        margin-bottom: 10px;
        font-size: 2.5em;
      }

      .subtitle {
        color: #718096;
        font-size: 1.1em;
        margin-bottom: 20px;
      }

      .status-indicator {
        padding: 8px 16px;
        border-radius: 20px;
        font-weight: bold;
        margin: 10px 0;
        display: inline-block;
      }

      #requestStatus {
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: bold;
        margin: 5px 0;
        display: inline-block;
      }

      .status-ready {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }

      .status-processing {
        background-color: #fff3cd;
        color: #856404;
        border: 1px solid #ffeaa7;
      }

      .status-connected {
        background: #48bb78;
        color: white;
      }

      .status-disconnected {
        background: #f56565;
        color: white;
      }

      .tabs {
        display: flex;
        gap: 10px;
        margin-bottom: 30px;
        flex-wrap: wrap;
      }

      .tab {
        padding: 12px 24px;
        background: rgba(255, 255, 255, 0.9);
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.3s ease;
        color: #4a5568;
      }

      .tab:hover {
        background: rgba(255, 255, 255, 1);
        transform: translateY(-2px);
      }

      .tab.active {
        background: #4299e1;
        color: white;
      }

      .tab-content {
        display: none;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 30px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .tab-content.active {
        display: block;
      }

      .form-group {
        margin-bottom: 20px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        font-weight: 600;
        color: #4a5568;
      }

      input,
      textarea,
      select {
        width: 100%;
        padding: 12px;
        border: 2px solid #e2e8f0;
        border-radius: 8px;
        font-size: 1em;
        transition: border-color 0.3s ease;
      }

      input:focus,
      textarea:focus,
      select:focus {
        outline: none;
        border-color: #4299e1;
      }

      button {
        background: #4299e1;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.3s ease;
        margin-right: 10px;
        margin-bottom: 10px;
      }

      button:hover {
        background: #3182ce;
        transform: translateY(-2px);
      }

      button.secondary {
        background: #718096;
      }

      button.secondary:hover {
        background: #4a5568;
      }

      button.danger {
        background: #f56565;
      }

      button.danger:hover {
        background: #e53e3e;
      }

      .response {
        background: #f7fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 0.9em;
        white-space: pre-wrap;
        max-height: 400px;
        overflow-y: auto;
      }

      .response.error {
        background: #fed7d7;
        border-color: #f56565;
      }

      .response.success {
        background: #c6f6d5;
        border-color: #48bb78;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
      }

      .card {
        background: #f7fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 20px;
      }

      .card h3 {
        margin-bottom: 15px;
        color: #4a5568;
      }

      .user-list {
        max-height: 300px;
        overflow-y: auto;
      }

      .user-item {
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .user-info h4 {
        margin-bottom: 5px;
        color: #2d3748;
      }

      .user-info p {
        color: #718096;
        font-size: 0.9em;
      }

      .pagination {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
        margin-top: 20px;
      }

      .pagination button {
        padding: 8px 16px;
        font-size: 0.9em;
      }

      .pagination span {
        color: #4a5568;
        font-weight: 600;
      }

      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid #4299e1;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 30px;
      }

      .stat-card {
        background: linear-gradient(135deg, #4299e1, #3182ce);
        color: white;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
      }

      .stat-number {
        font-size: 2em;
        font-weight: bold;
        margin-bottom: 5px;
      }

      .stat-label {
        font-size: 0.9em;
        opacity: 0.9;
      }

      .alert {
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
      }

      .alert.info {
        background: #bee3f8;
        color: #2c5282;
        border: 1px solid #90cdf4;
      }

      .alert.warning {
        background: #feebc8;
        color: #7c2d12;
        border: 1px solid #fbd38d;
      }

      .alert.error {
        background: #fed7d7;
        color: #742a2a;
        border: 1px solid #fc8181;
      }

      .hidden {
        display: none;
      }

      @media (max-width: 768px) {
        .container {
          padding: 10px;
        }

        header {
          padding: 20px;
        }

        h1 {
          font-size: 2em;
        }

        .tabs {
          justify-content: center;
        }

        .grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
    <script src="/public/api-service.js"></script>
    <script src="/public/direct-api-client.js"></script>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>üöÄ QMemory Library Demo</h1>
        <p class="subtitle">
          Production-ready Node.js utility library - Interactive Testing Interface
        </p>
        <div id="serverStatus" class="status-indicator status-disconnected">
          üî¥ Server Status: Disconnected
        </div>
        <div id="requestStatus" class="status-ready">‚úÖ Ready</div>
        <div class="stats">
          <div class="stat-card">
            <div class="stat-number" id="totalUsers">0</div>
            <div class="stat-label">Total Users</div>
          </div>
          <div class="stat-card">
            <div class="stat-number" id="totalRequests">0</div>
            <div class="stat-label">API Requests</div>
          </div>
          <div class="stat-card">
            <div class="stat-number" id="successRate">0%</div>
            <div class="stat-label">Success Rate</div>
          </div>
        </div>
      </header>

      <div class="tabs">
        <button class="tab active" onclick="switchTab('overview', event)">üìä Overview</button>
        <button class="tab" onclick="switchTab('users', event)">üë• User Management</button>
        <button class="tab" onclick="switchTab('utils', event)">üõ†Ô∏è Utilities</button>
        <button class="tab" onclick="switchTab('email', event)">üìß Email Utils</button>
        <button class="tab" onclick="switchTab('memoize', event)">üß† Memoization</button>
        <button class="tab" onclick="switchTab('circuit', event)">‚ö° Circuit Breaker</button>
        <button class="tab" onclick="switchTab('queue', event)">üìã Queue Management</button>
        <button class="tab" onclick="switchTab('fast', event)">üöÄ Fast Operations</button>
        <button class="tab" onclick="switchTab('pagination', event)">üìÑ Pagination</button>
        <button class="tab" onclick="switchTab('cache', event)">üíæ Cache Utils</button>
        <button class="tab" onclick="switchTab('streaming', event)">üåä Streaming</button>
        <button class="tab" onclick="switchTab('fields', event)">üîß Field Utils</button>
        <button class="tab" onclick="switchTab('security', event)">üîí Security</button>
        <button class="tab" onclick="switchTab('storage', event)">üíΩ Storage</button>
        <button class="tab" onclick="switchTab('http', event)">üåê HTTP Utils</button>
        <button class="tab" onclick="switchTab('docs', event)">üìö Documentation</button>
      </div>

      <!-- Overview Tab -->
      <div id="overview" class="tab-content active">
        <h2>üéØ Library Overview</h2>
        <div class="alert info">
          <strong>Welcome!</strong> This interactive demo showcases all QMemory library
          functionality. Start by checking server connectivity below.
        </div>

        <div class="grid">
          <div class="card">
            <h3>üîó Server Connection</h3>
            <p>Test connectivity to the demo server:</p>
            <button
              onclick="checkServerHealth()"
              aria-label="Check server health status and connection"
            >
              Check Server Health
            </button>
            <button
              onclick="getServerInfo()"
              class="secondary"
              aria-label="Get detailed server information and status"
            >
              Get Server Info
            </button>
            <div id="healthResponse" class="response hidden"></div>
          </div>

          <div class="card">
            <h3>üìà Quick Stats</h3>
            <p>Real-time library statistics:</p>
            <button
              onclick="refreshStats()"
              aria-label="Refresh system statistics and performance metrics"
            >
              Refresh System Stats
            </button>
            <div id="statsResponse" class="response hidden"></div>
          </div>
        </div>

        <div class="card">
          <h3>üöÄ Features Available</h3>
          <ul>
            <li><strong>Document Operations:</strong> User-owned CRUD with MongoDB</li>
            <li><strong>HTTP Utilities:</strong> Standardized Express.js responses</li>
            <li><strong>In-Memory Storage:</strong> Development-friendly user storage</li>
            <li><strong>Basic Utilities:</strong> String, math, and validation helpers</li>
            <li><strong>Performance Monitoring:</strong> Built-in metrics and health checks</li>
            <li><strong>Error Handling:</strong> Comprehensive error patterns</li>
          </ul>
        </div>
      </div>

      <!-- User Management Tab -->
      <div id="users" class="tab-content">
        <h2>üë• User Management</h2>

        <div class="grid">
          <div class="card">
            <h3>Create User</h3>
            <form id="createUserForm">
              <div class="form-group">
                <label for="username">Username * (letters, numbers, underscores only)</label>
                <input
                  type="text"
                  id="username"
                  name="username"
                  required
                  placeholder="Enter username"
                />
              </div>
              <div class="form-group">
                <label for="displayName">Display Name</label>
                <input
                  type="text"
                  id="displayName"
                  name="displayName"
                  placeholder="Enter display name (shown to other users)"
                />
              </div>
              <button type="submit">Create User</button>
              <button type="button" onclick="clearCreateForm()" class="secondary">Clear</button>
            </form>
            <div id="createUserResponse" class="response hidden"></div>
          </div>

          <div class="card">
            <h3>Find User</h3>
            <div class="form-group">
              <label for="userId">User ID (numeric, required)</label>
              <input type="number" id="userId" placeholder="Enter user ID" />
            </div>
            <button onclick="findUser()">Find User</button>
            <button onclick="findUserByUsername()" class="secondary">Find by Username</button>
            <div id="findUserResponse" class="response hidden"></div>
          </div>

          <div class="card">
            <h3>Update User</h3>
            <form id="updateUserForm">
              <div class="form-group">
                <label for="updateUserId">User ID *</label>
                <input
                  type="number"
                  id="updateUserId"
                  name="updateUserId"
                  required
                  placeholder="Enter numeric user ID (e.g., 123)"
                />
              </div>
              <div class="form-group">
                <label for="updateUsername">Username (replaces current username)</label>
                <input
                  type="text"
                  id="updateUsername"
                  name="updateUsername"
                  placeholder="Enter new username"
                />
              </div>
              <div class="form-group">
                <label for="updateDisplayName">Display Name</label>
                <input
                  type="text"
                  id="updateDisplayName"
                  name="updateDisplayName"
                  placeholder="Enter new display name (replaces current one)"
                />
              </div>
              <div class="form-group">
                <label for="updateGithubId">GitHub ID</label>
                <input
                  type="text"
                  id="updateGithubId"
                  name="updateGithubId"
                  placeholder="Enter GitHub username (without @)"
                />
              </div>
              <div class="form-group">
                <label for="updateAvatar">Avatar URL</label>
                <input
                  type="text"
                  id="updateAvatar"
                  name="updateAvatar"
                  placeholder="Enter avatar URL"
                />
              </div>
              <button type="submit">Update User</button>
              <button type="button" onclick="clearUpdateForm()" class="secondary">Clear</button>
            </form>
            <div id="updateUserResponse" class="response hidden"></div>
          </div>
        </div>

        <div class="card">
          <h3>User List with Pagination</h3>
          <div class="grid">
            <div>
              <label for="page">Page:</label>
              <input type="number" id="page" value="1" min="1" style="width: 80px" />
            </div>
            <div>
              <label for="limit">Limit:</label>
              <select id="limit">
                <option value="5">5</option>
                <option value="10" selected>10</option>
                <option value="20">20</option>
                <option value="50">50</option>
              </select>
            </div>
          </div>
          <button
            onclick="loadUsers()"
            aria-label="Load paginated user list with current page and limit settings"
          >
            Load User List
          </button>
          <button
            onclick="loadAllUsers()"
            class="secondary"
            aria-label="Load complete user list without pagination (may be slow)"
          >
            Load All Users
          </button>
          <button
            onclick="clearAllUsers()"
            class="danger"
            aria-label="Delete all users from database - this action cannot be undone"
          >
            ‚ö†Ô∏è Delete All Users (Cannot Undo)
          </button>

          <div id="userList" class="user-list hidden"></div>
          <div id="userPagination" class="pagination hidden"></div>
          <div id="loadUsersResponse" class="response hidden"></div>
        </div>
      </div>

      <!-- Utilities Tab -->
      <div id="utils" class="tab-content">
        <h2>üõ†Ô∏è Basic Utilities</h2>

        <div class="grid">
          <div class="card">
            <h3>Greeting Utility</h3>
            <div class="form-group">
              <label for="greetName">Name:</label>
              <input type="text" id="greetName" placeholder="Enter name" />
            </div>
            <button onclick="testGreet()">Test Greet</button>
            <div id="greetResponse" class="response hidden"></div>
          </div>

          <div class="card">
            <h3>Math Utilities</h3>
            <div class="form-group">
              <label for="addA">Number A:</label>
              <input type="number" id="addA" placeholder="First number" />
            </div>
            <div class="form-group">
              <label for="addB">Number B:</label>
              <input type="number" id="addB" placeholder="Second number" />
            </div>
            <button onclick="testAdd()">Test Addition</button>
            <div id="addResponse" class="response hidden"></div>
          </div>

          <div class="card">
            <h3>Even/Odd Check</h3>
            <div class="form-group">
              <label for="evenNum">Number:</label>
              <input type="number" id="evenNum" placeholder="Enter integer" />
            </div>
            <button onclick="testEven()">Test Even</button>
            <div id="evenResponse" class="response hidden"></div>
          </div>

          <div class="card">
            <h3>Deduplication</h3>
            <div class="form-group">
              <label for="dedupeInput">Array (comma-separated):</label>
              <input type="text" id="dedupeInput" placeholder="apple, banana, apple, orange" />
            </div>
            <button onclick="testDedupe()">Test Dedupe</button>
            <div id="dedupeResponse" class="response hidden"></div>
          </div>
        </div>
      </div>

      <!-- Email Utils Tab -->
      <div id="email" class="tab-content">
        <h2>üìß Email Utilities</h2>
        <div class="alert info">
          <strong>Email utilities</strong> provide validation, normalization, and parsing functions for email addresses.
        </div>
        <div class="grid">
          <div class="card">
            <h3>Email Validation</h3>
            <div class="form-group">
              <label for="emailInput">Email Address:</label>
              <input type="text" id="emailInput" placeholder="user@example.com" />
            </div>
            <button onclick="testEmailValidation()">Validate Email</button>
            <button onclick="testEmailNormalize()" class="secondary">Normalize Email</button>
            <div id="emailValidationResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Email Domain Extraction</h3>
            <div class="form-group">
              <label for="emailDomainInput">Email Address:</label>
              <input type="text" id="emailDomainInput" placeholder="user@example.com" />
            </div>
            <button onclick="testEmailDomain()">Extract Domain</button>
            <div id="emailDomainResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Batch Email Filtering</h3>
            <div class="form-group">
              <label for="emailListInput">Email List (comma-separated):</label>
              <textarea id="emailListInput" rows="3" placeholder="user1@example.com, invalid-email, user2@test.com"></textarea>
            </div>
            <button onclick="testFilterEmails()">Filter Valid Emails</button>
            <div id="emailFilterResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Email Target Creation</h3>
            <div class="form-group">
              <label for="emailTargetName">Name:</label>
              <input type="text" id="emailTargetName" placeholder="John Doe" />
            </div>
            <div class="form-group">
              <label for="emailTargetAddress">Email:</label>
              <input type="text" id="emailTargetAddress" placeholder="john@example.com" />
            </div>
            <button onclick="testCreateEmailTarget()">Create Email Target</button>
            <div id="emailTargetResponse" class="response hidden"></div>
          </div>
        </div>
      </div>

      <!-- Memoization Tab -->
      <div id="memoize" class="tab-content">
        <h2>üß† Memoization Utilities</h2>
        <div class="alert info">
          <strong>Memoization</strong> caches function results to avoid redundant computation. Supports TTL-based expiration.
        </div>
        <div class="grid">
          <div class="card">
            <h3>Basic Memoization</h3>
            <div class="form-group">
              <label for="memoFibInput">Fibonacci Number (n):</label>
              <input type="number" id="memoFibInput" value="35" min="1" max="45" />
            </div>
            <button onclick="testMemoizedFib()">Calculate (Memoized)</button>
            <button onclick="testUnmemoizedFib()" class="secondary">Calculate (Unmemoized)</button>
            <div id="memoFibResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>TTL-Based Memoization</h3>
            <div class="form-group">
              <label for="memoTTLInput">Value to cache:</label>
              <input type="text" id="memoTTLInput" placeholder="Enter any value" />
            </div>
            <div class="form-group">
              <label for="memoTTLDuration">TTL (milliseconds):</label>
              <input type="number" id="memoTTLDuration" value="5000" min="1000" />
            </div>
            <button onclick="testMemoWithTTL()">Cache with TTL</button>
            <button onclick="testMemoTTLExpiry()" class="secondary">Check Expiry</button>
            <div id="memoTTLResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Memoization Stats</h3>
            <button onclick="getMemoStats()">Get Cache Stats</button>
            <button onclick="clearMemoCache()" class="danger">Clear Cache</button>
            <div id="memoStatsResponse" class="response hidden"></div>
          </div>
        </div>
      </div>

      <!-- Circuit Breaker Tab -->
      <div id="circuit" class="tab-content">
        <h2>‚ö° Circuit Breaker Pattern</h2>
        <div class="alert info">
          <strong>Circuit Breaker</strong> prevents cascading failures by monitoring service health and short-circuiting requests when failures exceed thresholds.
        </div>
        <div class="grid">
          <div class="card">
            <h3>Circuit Breaker Demo</h3>
            <div class="form-group">
              <label for="cbFailureRate">Simulated Failure Rate (%):</label>
              <input type="number" id="cbFailureRate" value="50" min="0" max="100" />
            </div>
            <button onclick="testCircuitBreaker()">Test Circuit Breaker</button>
            <button onclick="triggerCircuitOpen()" class="danger">Force Failures</button>
            <div id="circuitBreakerResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Circuit State</h3>
            <button onclick="getCircuitState()">Get Current State</button>
            <button onclick="resetCircuit()" class="secondary">Reset Circuit</button>
            <div id="circuitStateResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Circuit Breaker Factory</h3>
            <div class="form-group">
              <label for="cbServiceName">Service Name:</label>
              <input type="text" id="cbServiceName" value="demo-service" />
            </div>
            <button onclick="createManagedBreaker()">Create Managed Breaker</button>
            <button onclick="getFactoryStats()" class="secondary">Get Factory Stats</button>
            <div id="circuitFactoryResponse" class="response hidden"></div>
          </div>
        </div>
      </div>

      <!-- Queue Management Tab -->
      <div id="queue" class="tab-content">
        <h2>üìã Queue Management</h2>
        <div class="alert info">
          <strong>Queue utilities</strong> provide async job processing, concurrency limiting, and periodic task management.
        </div>
        <div class="grid">
          <div class="card">
            <h3>Async Queue</h3>
            <div class="form-group">
              <label for="queueJobCount">Number of Jobs:</label>
              <input type="number" id="queueJobCount" value="5" min="1" max="20" />
            </div>
            <div class="form-group">
              <label for="queueConcurrency">Concurrency Limit:</label>
              <input type="number" id="queueConcurrency" value="2" min="1" max="10" />
            </div>
            <button onclick="testAsyncQueue()">Run Queue Jobs</button>
            <div id="asyncQueueResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Concurrency Limiter</h3>
            <div class="form-group">
              <label for="limiterMaxConcurrent">Max Concurrent:</label>
              <input type="number" id="limiterMaxConcurrent" value="3" min="1" max="10" />
            </div>
            <button onclick="testConcurrencyLimiter()">Test Limiter</button>
            <div id="concurrencyLimiterResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Periodic Tasks</h3>
            <div class="form-group">
              <label for="periodicInterval">Interval (ms):</label>
              <input type="number" id="periodicInterval" value="1000" min="500" />
            </div>
            <button onclick="startPeriodicTask()">Start Task</button>
            <button onclick="stopPeriodicTask()" class="danger">Stop Task</button>
            <button onclick="getActivePeriodicTasks()" class="secondary">List Active</button>
            <div id="periodicTaskResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Queue State Manager</h3>
            <button onclick="getQueueState()">Get Queue State</button>
            <button onclick="enforceQueueLimit()" class="secondary">Enforce Limit</button>
            <div id="queueStateResponse" class="response hidden"></div>
          </div>
        </div>
      </div>

      <!-- Fast Operations Tab -->
      <div id="fast" class="tab-content">
        <h2>üöÄ Fast Operations</h2>
        <div class="alert info">
          <strong>Fast operations</strong> provide optimized utilities for math, string manipulation, hashing, and memory operations.
        </div>
        <div class="grid">
          <div class="card">
            <h3>FastMath</h3>
            <div class="form-group">
              <label for="fastMathA">Number A:</label>
              <input type="number" id="fastMathA" value="100" />
            </div>
            <div class="form-group">
              <label for="fastMathB">Number B:</label>
              <input type="number" id="fastMathB" value="50" />
            </div>
            <button onclick="testFastMath()">Test FastMath</button>
            <div id="fastMathResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>FastString</h3>
            <div class="form-group">
              <label for="fastStringInput">Input String:</label>
              <input type="text" id="fastStringInput" value="Hello World Test String" />
            </div>
            <button onclick="testFastString()">Test FastString</button>
            <div id="fastStringResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>FastHash</h3>
            <div class="form-group">
              <label for="fastHashInput">Input to Hash:</label>
              <input type="text" id="fastHashInput" value="test-data-to-hash" />
            </div>
            <button onclick="testFastHash()">Generate Hash</button>
            <div id="fastHashResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Object Pool</h3>
            <div class="form-group">
              <label for="poolSize">Pool Size:</label>
              <input type="number" id="poolSize" value="10" min="1" max="100" />
            </div>
            <button onclick="testObjectPool()">Test Object Pool</button>
            <div id="objectPoolResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Lock-Free Queue</h3>
            <div class="form-group">
              <label for="lfqOperations">Operations Count:</label>
              <input type="number" id="lfqOperations" value="1000" min="100" max="10000" />
            </div>
            <button onclick="testLockFreeQueue()">Test Lock-Free Queue</button>
            <div id="lockFreeQueueResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>FastTimer</h3>
            <button onclick="testFastTimer()">Benchmark Timer Precision</button>
            <div id="fastTimerResponse" class="response hidden"></div>
          </div>
        </div>
      </div>

      <!-- Pagination Tab -->
      <div id="pagination" class="tab-content">
        <h2>üìÑ Pagination Utilities</h2>
        <div class="alert info">
          <strong>Pagination utilities</strong> provide offset-based and cursor-based pagination with validation.
        </div>
        <div class="grid">
          <div class="card">
            <h3>Offset Pagination</h3>
            <div class="form-group">
              <label for="paginationPage">Page:</label>
              <input type="number" id="paginationPage" value="1" min="1" />
            </div>
            <div class="form-group">
              <label for="paginationLimit">Limit:</label>
              <input type="number" id="paginationLimit" value="10" min="1" max="100" />
            </div>
            <div class="form-group">
              <label for="paginationTotal">Total Items:</label>
              <input type="number" id="paginationTotal" value="100" min="0" />
            </div>
            <button onclick="testOffsetPagination()">Generate Pagination Meta</button>
            <div id="offsetPaginationResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Cursor Pagination</h3>
            <div class="form-group">
              <label for="cursorInput">Cursor (base64):</label>
              <input type="text" id="cursorInput" placeholder="Leave empty for first page" />
            </div>
            <div class="form-group">
              <label for="cursorLimit">Limit:</label>
              <input type="number" id="cursorLimit" value="10" min="1" max="100" />
            </div>
            <button onclick="testCursorPagination()">Test Cursor Pagination</button>
            <button onclick="generateCursor()" class="secondary">Generate Cursor</button>
            <div id="cursorPaginationResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Sorting Validation</h3>
            <div class="form-group">
              <label for="sortField">Sort Field:</label>
              <input type="text" id="sortField" value="createdAt" />
            </div>
            <div class="form-group">
              <label for="sortOrder">Sort Order:</label>
              <select id="sortOrder">
                <option value="asc">Ascending</option>
                <option value="desc">Descending</option>
              </select>
            </div>
            <button onclick="testSortingValidation()">Validate Sorting</button>
            <div id="sortingValidationResponse" class="response hidden"></div>
          </div>
        </div>
      </div>

      <!-- Cache Utils Tab -->
      <div id="cache" class="tab-content">
        <h2>üíæ Cache Utilities</h2>
        <div class="alert info">
          <strong>Cache utilities</strong> include LRU cache, bounded collections, and memory-optimized caching.
        </div>
        <div class="grid">
          <div class="card">
            <h3>LRU Cache</h3>
            <div class="form-group">
              <label for="lruKey">Key:</label>
              <input type="text" id="lruKey" placeholder="cache-key" />
            </div>
            <div class="form-group">
              <label for="lruValue">Value:</label>
              <input type="text" id="lruValue" placeholder="cache-value" />
            </div>
            <button onclick="lruSet()">Set</button>
            <button onclick="lruGet()" class="secondary">Get</button>
            <button onclick="lruDelete()" class="danger">Delete</button>
            <div id="lruCacheResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Bounded Queue</h3>
            <div class="form-group">
              <label for="bqMaxSize">Max Size:</label>
              <input type="number" id="bqMaxSize" value="5" min="1" max="20" />
            </div>
            <div class="form-group">
              <label for="bqItemCount">Items to Add:</label>
              <input type="number" id="bqItemCount" value="10" min="1" max="50" />
            </div>
            <button onclick="testBoundedQueue()">Test Bounded Queue</button>
            <div id="boundedQueueResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Bounded Map</h3>
            <div class="form-group">
              <label for="bmMaxSize">Max Size:</label>
              <input type="number" id="bmMaxSize" value="5" min="1" max="20" />
            </div>
            <button onclick="testBoundedMap()">Test Bounded Map</button>
            <div id="boundedMapResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Cache Metrics</h3>
            <button onclick="getCacheMetrics()">Get Cache Metrics</button>
            <button onclick="resetCacheMetrics()" class="secondary">Reset Metrics</button>
            <div id="cacheMetricsResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Memory-Optimized Cache</h3>
            <div class="form-group">
              <label for="mocMaxItems">Max Items:</label>
              <input type="number" id="mocMaxItems" value="100" min="10" max="1000" />
            </div>
            <button onclick="testMemoryOptimizedCache()">Test Memory Cache</button>
            <button onclick="getMemoryCacheStats()" class="secondary">Get Stats</button>
            <div id="memoryOptimizedCacheResponse" class="response hidden"></div>
          </div>
        </div>
      </div>

      <!-- Streaming Tab -->
      <div id="streaming" class="tab-content">
        <h2>üåä Streaming Utilities</h2>
        <div class="alert info">
          <strong>Streaming utilities</strong> provide chunked processing, JSON streaming, and scalable file reading.
        </div>
        <div class="grid">
          <div class="card">
            <h3>Safe JSON Operations</h3>
            <div class="form-group">
              <label for="jsonInput">JSON Input:</label>
              <textarea id="jsonInput" rows="3" placeholder='{"key": "value"}'></textarea>
            </div>
            <button onclick="testSafeJsonParse()">Safe Parse</button>
            <button onclick="testSafeJsonStringify()" class="secondary">Safe Stringify</button>
            <div id="safeJsonResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Chunked Processing</h3>
            <div class="form-group">
              <label for="chunkDataSize">Data Size (items):</label>
              <input type="number" id="chunkDataSize" value="100" min="10" max="1000" />
            </div>
            <div class="form-group">
              <label for="chunkSize">Chunk Size:</label>
              <input type="number" id="chunkSize" value="10" min="1" max="100" />
            </div>
            <button onclick="testChunkedProcessing()">Process in Chunks</button>
            <div id="chunkedProcessingResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Line Stream Processing</h3>
            <div class="form-group">
              <label for="lineStreamInput">Multi-line Text:</label>
              <textarea id="lineStreamInput" rows="4" placeholder="Line 1&#10;Line 2&#10;Line 3"></textarea>
            </div>
            <button onclick="testLineStreamProcessing()">Process Lines</button>
            <div id="lineStreamResponse" class="response hidden"></div>
          </div>
        </div>
      </div>

      <!-- Field Utils Tab -->
      <div id="fields" class="tab-content">
        <h2>üîß Field Utilities</h2>
        <div class="alert info">
          <strong>Field utilities</strong> handle field normalization, denormalization, and type mapping for database operations.
        </div>
        <div class="grid">
          <div class="card">
            <h3>Field Normalization</h3>
            <div class="form-group">
              <label for="fieldNameInput">Field Name:</label>
              <input type="text" id="fieldNameInput" placeholder="UserName, first_name, etc." />
            </div>
            <button onclick="testNormalizeField()">Normalize</button>
            <button onclick="testDenormalizeField()" class="secondary">Denormalize</button>
            <div id="fieldNormalizeResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Object Field Normalization</h3>
            <div class="form-group">
              <label for="objectFieldsInput">Object (JSON):</label>
              <textarea id="objectFieldsInput" rows="3" placeholder='{"FirstName": "John", "LastName": "Doe"}'></textarea>
            </div>
            <button onclick="testNormalizeObjectFields()">Normalize Object</button>
            <button onclick="testDenormalizeObjectFields()" class="secondary">Denormalize Object</button>
            <div id="objectFieldsResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Collection Name</h3>
            <div class="form-group">
              <label for="modelNameInput">Model Name:</label>
              <input type="text" id="modelNameInput" placeholder="User, BlogPost, etc." />
            </div>
            <button onclick="testGetCollectionName()">Get Collection Name</button>
            <div id="collectionNameResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Type Mapping</h3>
            <div class="form-group">
              <label for="typeMapInput">Type Name:</label>
              <select id="typeMapInput">
                <option value="string">String</option>
                <option value="number">Number</option>
                <option value="boolean">Boolean</option>
                <option value="date">Date</option>
                <option value="objectId">ObjectId</option>
                <option value="array">Array</option>
                <option value="object">Object</option>
              </select>
            </div>
            <button onclick="testGetMongoType()">Get Mongo Type</button>
            <button onclick="testGetSupportedTypes()" class="secondary">List Supported Types</button>
            <div id="typeMapResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Serialization</h3>
            <div class="form-group">
              <label for="serializeInput">Document (JSON):</label>
              <textarea id="serializeInput" rows="3" placeholder='{"_id": "abc123", "name": "Test", "__v": 0}'></textarea>
            </div>
            <button onclick="testSerializeDocument()">Serialize Document</button>
            <button onclick="testSerializeWithoutFields()" class="secondary">Serialize Without Fields</button>
            <div id="serializeResponse" class="response hidden"></div>
          </div>
        </div>
      </div>

      <!-- Security Tab -->
      <div id="security" class="tab-content">
        <h2>üîí Security & Privacy</h2>
        <div class="alert info">
          <strong>Security middleware</strong> provides rate limiting, headers security, and privacy compliance utilities.
        </div>
        <div class="grid">
          <div class="card">
            <h3>Rate Limiter Demo</h3>
            <div class="form-group">
              <label for="rateLimitRequests">Requests to Send:</label>
              <input type="number" id="rateLimitRequests" value="15" min="1" max="50" />
            </div>
            <button onclick="testRateLimiter()">Test Rate Limiter</button>
            <div id="rateLimiterResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Security Headers</h3>
            <button onclick="getSecurityHeaders()">Get Current Headers</button>
            <button onclick="testHelmetConfig()" class="secondary">Test Helmet Config</button>
            <div id="securityHeadersResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Privacy Compliance</h3>
            <button onclick="testPrivacyHeaders()">Privacy Headers</button>
            <button onclick="testCCPACompliance()" class="secondary">CCPA Compliance</button>
            <div id="privacyComplianceResponse" class="response hidden"></div>
          </div>
          <div class="card">
            <h3>Data Management</h3>
            <div class="form-group">
              <label for="dataUserId">User ID for Data Request:</label>
              <input type="text" id="dataUserId" placeholder="user-123" />
            </div>
            <button onclick="testDataExport()">Export User Data</button>
            <button onclick="testDataDeletion()" class="danger">Request Data Deletion</button>
            <div id="dataManagementResponse" class="response hidden"></div>
          </div>
        </div>
      </div>

      <!-- Storage Tab -->
      <div id="storage" class="tab-content">
        <h2>üíΩ Storage Operations</h2>

        <div class="alert info">
          <strong>Note:</strong> The demo uses in-memory storage. Data is lost when the server
          restarts.
        </div>

        <div class="grid">
          <div class="card">
            <h3>Storage Statistics</h3>
            <button onclick="getStorageStats()">Get Storage Stats</button>
            <button onclick="testStorageCapacity()" class="secondary">Test Capacity</button>
            <div id="storageStatsResponse" class="response hidden"></div>
          </div>

          <div class="card">
            <h3>Batch Operations</h3>
            <div class="form-group">
              <label for="batchCount">Number of Users:</label>
              <input type="number" id="batchCount" value="5" min="1" max="20" />
            </div>
            <button onclick="createBatchUsers()">Create Batch Users</button>
            <button onclick="testBatchDelete()" class="secondary">Test Batch Delete</button>
            <div id="batchResponse" class="response hidden"></div>
          </div>
        </div>

        <div class="card">
          <h3>Storage Performance Test</h3>
          <p>Test storage performance with multiple operations:</p>
          <button onclick="runPerformanceTest()">Run Performance Test</button>
          <button onclick="stressTestStorage()" class="secondary">Stress Test</button>
          <div id="performanceResponse" class="response hidden"></div>
        </div>
      </div>

      <!-- HTTP Utils Tab -->
      <div id="http" class="tab-content">
        <h2>üåê HTTP Utilities</h2>

        <div class="grid">
          <div class="card">
            <h3>Error Response Testing</h3>
            <button onclick="testNotFound()">Test 404 Not Found</button>
            <button onclick="testConflict()" class="secondary">Test 409 Conflict</button>
            <button onclick="testServerError()" class="danger">Test 500 Server Error</button>
            <button onclick="testServiceUnavailable()" class="secondary">
              Test 503 Service Unavailable
            </button>
            <div id="httpErrorResponse" class="response hidden"></div>
          </div>

          <div class="card">
            <h3>Validation Testing</h3>
            <div class="form-group">
              <label for="validationData">Test Data:</label>
              <input type="text" id="validationData" placeholder="Enter test data" />
            </div>
            <button onclick="testValidationError()">Test Validation Error</button>
            <button onclick="testAuthError()" class="secondary">Test Auth Error</button>
            <div id="httpValidationResponse" class="response hidden"></div>
          </div>
        </div>

        <div class="card">
          <h3>Request/Response Analysis</h3>
          <p>Analyze HTTP request patterns and responses:</p>
          <button onclick="analyzeRequests()">Analyze Request Patterns</button>
          <button onclick="testResponseFormat()" class="secondary">Test Response Format</button>
          <div id="httpAnalysisResponse" class="response hidden"></div>
        </div>
      </div>

      <!-- Documentation Tab -->
      <div id="docs" class="tab-content">
        <h2>üìö Documentation & Examples</h2>

        <div class="card">
          <h3>API Endpoints</h3>
          <div class="grid">
            <div>
              <h4>Core Endpoints</h4>
              <ul>
                <li><code>GET /health</code> - Service health check</li>
                <li><code>GET /</code> - API information</li>
                <li><code>GET /users</code> - List users (paginated)</li>
                <li><code>POST /users</code> - Create user</li>
                <li><code>GET /users/:id</code> - Get user by ID</li>
                <li><code>PUT /users/:id</code> - Update user</li>
                <li><code>DELETE /users/:id</code> - Delete user</li>
                <li><code>GET /users/by-username/:username</code> - Get user by username</li>
                <li><code>POST /users/clear</code> - Clear all users</li>
              </ul>
            </div>
            <div>
              <h4>Response Format</h4>
              <pre>
{
  "message": "Success message",
  "timestamp": "2024-01-01T00:00:00.000Z",
  "data": { ... }
}</pre
              >
            </div>
          </div>
        </div>

        <div class="card">
          <h3>Library Features</h3>
          <div class="grid">
            <div>
              <h4>Document Operations</h4>
              <ul>
                <li>User-owned document CRUD</li>
                <li>Automatic ownership enforcement</li>
                <li>Uniqueness validation</li>
                <li>Bulk operations support</li>
              </ul>
            </div>
            <div>
              <h4>HTTP Utilities</h4>
              <ul>
                <li>Standardized error responses</li>
                <li>Request ID generation</li>
                <li>Response sanitization</li>
                <li>Timestamp handling</li>
              </ul>
            </div>
            <div>
              <h4>Storage Options</h4>
              <ul>
                <li>In-memory storage (development)</li>
                <li>MongoDB integration (production)</li>
                <li>Connection pooling</li>
                <li>Health monitoring</li>
              </ul>
            </div>
            <div>
              <h4>Utilities</h4>
              <ul>
                <li>String manipulation</li>
                <li>Math operations</li>
                <li>Array deduplication</li>
                <li>Input validation</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="card">
          <h3>Usage Examples</h3>
          <div class="grid">
            <div>
              <h4>Basic User Creation</h4>
              <pre>
const response = await fetch('/users', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    username: 'johndoe',
    displayName: 'John Doe'
  })
});</pre
              >
            </div>
            <div>
              <h4>Paginated User Listing</h4>
              <pre>
const response = await fetch('/users?page=1&limit=10');
const data = await response.json();
console.log(data.data.users); // User array (nested in data.data)
console.log(data.data.pagination); // Pagination info</pre
              >
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Global variables
      const API_BASE = window.location.origin;
      let requestCount = 0;
      let successCount = 0;
      let currentPage = 1;
      let currentLimit = 10;

      // Import API service
      // Note: In a real project, you'd use proper module imports
      // For demo purposes, we'll inline the API service functionality

      // Validation rules cache
      let validationRules = null;

      // Load validation rules from backend
      async function loadValidationRules() {
        try {
          const data = await apiRequest('/validation/rules');
          validationRules = data.data;
          console.log('Validation rules loaded:', validationRules);
        } catch (error) {
          console.warn('Failed to load validation rules:', error);
          // Fallback to basic validation
          validationRules = {
            username: { required: true, minLength: 1, maxLength: 50, pattern: '^[a-zA-Z0-9_-]+$' },
            displayName: { required: false, minLength: 1, maxLength: 100, pattern: '^[a-zA-Z0-9\\s_-]+$' },
            email: { required: false, pattern: '^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$' },
            url: { required: false }
          };
        }
      }

      // Validate input using backend rules
      function validateInput(fieldName, value) {
        // Block validation if rules not loaded yet to prevent race condition
        if (!validationRules) {
          return { valid: false, error: 'Validation rules not loaded yet. Please try again.' };
        }

        if (!validationRules[fieldName]) {
          return { valid: true }; // No validation rule for this field
        }

        const rule = validationRules[fieldName];
        let isValid = true;
        let error = '';

        // Required check
        if (rule.required && (!value || !value.trim())) {
          isValid = false;
          error = `${fieldName} is required`;
        }

        // Length checks
        if (isValid && value) {
          if (rule.minLength && value.length < rule.minLength) {
            isValid = false;
            error = `${fieldName} must be at least ${rule.minLength} characters`;
          }
          if (rule.maxLength && value.length > rule.maxLength) {
            isValid = false;
            error = `${fieldName} must be no more than ${rule.maxLength} characters`;
          }
        }

        // Pattern check with basic validation to prevent regex injection
        if (isValid && value && rule.pattern) {
          try {
            const regex = new RegExp(rule.pattern);
            if (!regex.test(value)) {
              isValid = false;
              error = rule.message || `${fieldName} format is invalid`;
            }
          } catch (regexError) {
            console.warn('Invalid regex pattern in validation rules:', rule.pattern);
            isValid = false;
            error = `${fieldName} validation error`;
          }
        }

        return { valid: isValid, error };
      }

      // Initialize
      document.addEventListener('DOMContentLoaded', function () {
        loadValidationRules(); // Load validation rules first
        checkServerHealth();
        setupEventListeners();
      });

      // Setup event listeners
      function setupEventListeners() {
        document.getElementById('createUserForm').addEventListener('submit', function (e) {
          e.preventDefault();
          createUser();
        });
        document.getElementById('updateUserForm').addEventListener('submit', function (e) {
          e.preventDefault();
          updateUser();
        });
      }

      // Tab switching
      function switchTab(tabName, event) {
        // Hide all tabs
        document.querySelectorAll('.tab-content').forEach(tab => {
          tab.classList.remove('active');
        });

        // Remove active class from all tab buttons
        document.querySelectorAll('.tab').forEach(tab => {
          tab.classList.remove('active');
        });

        // Show selected tab
        document.getElementById(tabName).classList.add('active');

        // Add active class to clicked tab button
        if (event && event.target) {
          event.target.classList.add('active');
        }
      }

      // Server connectivity
      async function checkServerHealth() {
        try {
          const response = await fetch(`${API_BASE}/health`);

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const data = await response.json();

          updateServerStatus(true);
          showResponse('healthResponse', data, 'success');

          // Update stats
          if (data && data.userCount !== undefined) {
            document.getElementById('totalUsers').textContent = data.userCount;
          }
        } catch (error) {
          updateServerStatus(false);
          showResponse('healthResponse', { error: error.message || 'Unknown error' }, 'error');
        }
      }

      async function getServerInfo() {
        try {
          const data = await apiRequest('/');
          showResponse('healthResponse', data, 'success');
        } catch (error) {
          showResponse('healthResponse', { error: error.message }, 'error');
        }
      }

      function updateServerStatus(connected) {
        const statusEl = document.getElementById('serverStatus');
        if (connected) {
          statusEl.className = 'status-indicator status-connected';
          statusEl.innerHTML = 'üü¢ Server Status: Connected';
        } else {
          statusEl.className = 'status-indicator status-disconnected';
          statusEl.innerHTML = 'üî¥ Server Status: Disconnected';
        }
      }

      // User Management
      async function createUser() {
        const username = document.getElementById('username').value;
        const displayName = document.getElementById('displayName').value;

        // Validate username using backend rules
        const usernameValidation = validateInput('username', username);
        if (!usernameValidation.valid) {
          showResponse('createUserResponse', { error: usernameValidation.error }, 'error');
          return;
        }

        // Validate display name using backend rules
        if (displayName) {
          const displayNameValidation = validateInput('displayName', displayName);
          if (!displayNameValidation.valid) {
            showResponse('createUserResponse', { error: displayNameValidation.error }, 'error');
            return;
          }
        }

        try {
          const data = await apiRequest('/users', {
            method: 'POST',
            body: JSON.stringify({ username: username.trim(), displayName: displayName || null })
          });
          showResponse('createUserResponse', data, 'success');

          clearCreateForm();
          refreshStats();
        } catch (error) {
          showResponse('createUserResponse', { error: error.message || 'Network error' }, 'error');
        }
      }



      function clearCreateForm() {
        document.getElementById('username').value = '';
        document.getElementById('displayName').value = '';
      }

      function clearUpdateForm() {
        document.getElementById('updateUserId').value = '';
        document.getElementById('updateUsername').value = '';
        document.getElementById('updateDisplayName').value = '';
        document.getElementById('updateGithubId').value = '';
        document.getElementById('updateAvatar').value = '';
      }

      async function updateUser() {
        const userId = parseInt(document.getElementById('updateUserId').value);
        const username = document.getElementById('updateUsername').value;
        const displayName = document.getElementById('updateDisplayName').value;
        const githubId = document.getElementById('updateGithubId').value;
        const avatar = document.getElementById('updateAvatar').value;

        if (!userId || isNaN(userId) || userId <= 0) {
          showResponse('updateUserResponse', { error: 'Valid User ID is required' }, 'error');
          return;
        }

        const updateData = {};

        // Validate username if provided
        if (username) {
          const usernameValidation = validateInput('username', username);
          if (!usernameValidation.valid) {
            showResponse('updateUserResponse', { error: usernameValidation.error }, 'error');
            return;
          }
          updateData.username = username.trim();
        }

        // Validate display name if provided
        if (displayName) {
          const displayNameValidation = validateInput('displayName', displayName);
          if (!displayNameValidation.valid) {
            showResponse('updateUserResponse', { error: displayNameValidation.error }, 'error');
            return;
          }
          updateData.displayName = displayName.trim();
        }

        if (githubId) updateData.githubId = githubId.trim();
        if (avatar) updateData.avatar = avatar.trim();

        if (Object.keys(updateData).length === 0) {
          showResponse('updateUserResponse', { error: 'At least one field must be provided for update' }, 'error');
          return;
        }

        try {
          const data = await apiRequest(`/users/${userId}`, {
            method: 'PUT',
            body: JSON.stringify(updateData)
          });
          showResponse('updateUserResponse', data, 'success');
          clearUpdateForm();
          refreshStats();
        } catch (error) {
          showResponse('updateUserResponse', { error: error.message || 'Network error' }, 'error');
        }
      }

      async function findUser() {
        const userId = document.getElementById('userId').value;

        if (!userId || isNaN(userId) || userId <= 0) {
          showResponse('findUserResponse', { error: 'Valid User ID is required' }, 'error');
          return;
        }

        try {
          const data = await apiRequest(`/users/${parseInt(userId)}`);
          showResponse('findUserResponse', data, 'success');
        } catch (error) {
          showResponse('findUserResponse', { error: error.message || 'Network error' }, 'error');
        }
      }

      async function findUserByUsername() {
        const username = prompt('Enter username to search:');
        if (!username) return;

        try {
          // Use the dedicated username endpoint instead of client-side filtering
          const data = await apiRequest(`/users/by-username/${encodeURIComponent(username)}`);
          showResponse('findUserResponse', data, 'success');
        } catch (error) {
          showResponse('findUserResponse', { error: error.message }, 'error');
        }
      }

      async function loadUsers() {
        const page = parseInt(document.getElementById('page').value) || 1;
        const limit = parseInt(document.getElementById('limit').value) || 10;

        if (page < 1 || limit < 1) {
          showResponse('loadUsersResponse', { error: 'Page and limit must be positive numbers' }, 'error');
          return;
        }

        try {
          const data = await apiRequest(`/users?page=${page}&limit=${limit}`);

          if (data && data.data) {
            displayUserList(data.data, data.pagination);
            showResponse('loadUsersResponse', data, 'success');
          } else {
            showResponse('loadUsersResponse', { error: 'Invalid response format' }, 'error');
          }
        } catch (error) {
          showResponse('loadUsersResponse', { error: error.message || 'Network error' }, 'error');
        }
      }

      async function loadAllUsers() {
        try {
          const data = await apiRequest('/users?page=1&limit=1000');

          if (data.data) {
            displayUserList(data.data, data.pagination);
            showResponse('loadUsersResponse', data, 'success');
          } else {
            showResponse('loadUsersResponse', data, 'error');
          }
        } catch (error) {
          showResponse('loadUsersResponse', { error: error.message }, 'error');
        }
      }

      async function clearAllUsers() {
        if (!confirm('Are you sure you want to delete all users? This action cannot be undone.')) {
          return;
        }

        try {
          const data = await apiRequest('/users/clear', {
            method: 'POST'
          });
          showResponse('loadUsersResponse', data, 'success');

          document.getElementById('userList').innerHTML = '';
          document.getElementById('userList').classList.add('hidden');
          refreshStats();
        } catch (error) {
          showResponse('loadUsersResponse', { error: error.message }, 'error');
        }
      }

      function displayUserList(users, pagination) {
        const listEl = document.getElementById('userList');
        const paginationEl = document.getElementById('userPagination');

        if (users.length === 0) {
          listEl.innerHTML = '<p>No users found.</p>';
          listEl.classList.remove('hidden');
          paginationEl.classList.add('hidden');
          return;
        }

        listEl.innerHTML = users
          .map(
            user => `
                <div class="user-item">
                    <div class="user-info">
                        <h4>${user.username} (ID: ${user.id})</h4>
                        <p>${user.displayName || 'No display name'}</p>
                    </div>
                    <div>
                        <button onclick="deleteUser(${user.id})" class="danger">Delete</button>
                    </div>
                </div>
            `
          )
          .join('');

        listEl.classList.remove('hidden');

        if (pagination) {
          paginationEl.innerHTML = `
                    <button onclick="changePage(${pagination.page - 1})" ${pagination.page <= 1 ? 'disabled' : ''}>Previous</button>
                    <span>Page ${pagination.page} of ${pagination.totalPages}</span>
                    <button onclick="changePage(${pagination.page + 1})" ${pagination.page >= pagination.totalPages ? 'disabled' : ''}>Next</button>
                `;
          paginationEl.classList.remove('hidden');
        }
      }

      function changePage(page) {
        if (page < 1) return;
        document.getElementById('page').value = page;
        loadUsers();
      }

      async function deleteUser(userId) {
        if (!userId || isNaN(userId) || userId <= 0) {
          showResponse('loadUsersResponse', { error: 'Valid User ID is required' }, 'error');
          return;
        }

        if (!confirm('Are you sure you want to delete this user?')) return;

        try {
          await apiRequest(`/users/${userId}`, {
            method: 'DELETE'
          });

          // Refresh current page
          loadUsers();
          refreshStats();
        } catch (error) {
          showResponse('loadUsersResponse', { error: error.error?.message || error.message || 'Network error during delete' }, 'error');
        }
      }

      // Utilities testing
      async function testGreet() {
        try {
          const name = document.getElementById('greetName').value || 'World';
          const data = await apiRequest(`/utils/greet?name=${encodeURIComponent(name)}`);
          showResponse('greetResponse', data, 'success');
        } catch (error) {
          showResponse('greetResponse', { error: error.message }, 'error');
        }
      }

      async function testAdd() {
        try {
          const a = parseFloat(document.getElementById('addA').value);
          const b = parseFloat(document.getElementById('addB').value);

          if (isNaN(a) || isNaN(b) || !isFinite(a) || !isFinite(b)) {
            showResponse('addResponse', { error: 'Please enter valid finite numbers' }, 'error');
            return;
          }

          const data = await apiRequest('/utils/math', {
            method: 'POST',
            body: JSON.stringify({ a, b, operation: 'add' }),
          });
          showResponse('addResponse', data, 'success');
        } catch (error) {
          showResponse('addResponse', { error: error.message }, 'error');
        }
      }

      async function testEven() {
        try {
          const num = parseInt(document.getElementById('evenNum').value);

          if (isNaN(num) || !isFinite(num)) {
            showResponse('evenResponse', { error: 'Please enter a valid integer' }, 'error');
            return;
          }

          const data = await apiRequest(`/utils/even/${num}`);
          showResponse('evenResponse', data, 'success');
        } catch (error) {
          showResponse('evenResponse', { error: error.message }, 'error');
        }
      }

      async function testDedupe() {
        const input = document.getElementById('dedupeInput').value;
        if (!input) {
          showResponse('dedupeResponse', { error: 'Please enter comma-separated values' }, 'error');
          return;
        }

        const items = input.split(',').map(item => item.trim());

        try {
          // Use backend deduplication endpoint for consistency
          const data = await apiRequest('/utils/dedupe', {
            method: 'POST',
            body: JSON.stringify({ items })
          });

          showResponse('dedupeResponse', data, 'success'); // Fixed: data not data.data
        } catch (error) {
          // Fallback to client-side deduplication if backend fails
          const deduped = [...new Set(items)];
          showResponse(
            'dedupeResponse',
            {
              original: items,
              deduped: deduped,
              removed: items.length - deduped.length,
              fallback: 'Client-side deduplication (backend unavailable)'
            },
            'success'
          );
        }
      }

      // Storage operations
      async function getStorageStats() {
        try {
          const data = await apiRequest('/health');

          if (data.data) {
            const stats = {
              userCount: data.data.userCount,
              memoryUsage: data.data.memory,
              uptime: data.data.uptime,
            };
            showResponse('storageStatsResponse', stats, 'success');
          } else {
            showResponse('storageStatsResponse', data, 'success');
          }
        } catch (error) {
          showResponse('storageStatsResponse', { error: error.message }, 'error');
        }
      }

      async function testStorageCapacity() {
        const batchSize = 10;
        const results = [];

        for (let i = 0; i < batchSize; i++) {
          try {
            await apiRequest('/users', {
              method: 'POST',
              body: JSON.stringify({
                username: `testuser_${Date.now()}_${i}`,
                displayName: `Test User ${i}`,
              }),
            });

            results.push({
              attempt: i + 1,
              success: true,
              status: 200,
            });
          } catch (error) {
            results.push({
              attempt: i + 1,
              success: false,
              error: error.message,
            });
          }
        }

        showResponse(
          'storageStatsResponse',
          {
            test: 'Storage Capacity Test',
            results: results,
            successful: results.filter(r => r.success).length,
            failed: results.filter(r => !r.success).length,
          },
          'success'
        );
      }

      async function createBatchUsers() {
        const count = parseInt(document.getElementById('batchCount').value);
        const results = [];

        for (let i = 0; i < count; i++) {
          try {
            await apiRequest('/users', {
              method: 'POST',
              body: JSON.stringify({
                username: `batch_${Date.now()}_${i}`,
                displayName: `Batch User ${i + 1}`,
              }),
            });

            results.push({ user: i + 1, status: 'created' });
          } catch (error) {
            results.push({ user: i + 1, status: 'error', error: error.message });
          }
        }

        showResponse(
          'batchResponse',
          {
            operation: 'Batch User Creation',
            requested: count,
            successful: results.filter(r => r.status === 'created').length,
            failed: results.filter(r => r.status !== 'created').length,
            results: results,
          },
          'success'
        );

        refreshStats();
      }

      async function testBatchDelete() {
        // First create some users to delete
        await createBatchUsers();

        // Then get users and delete them
        try {
          const data = await apiRequest('/users?page=1&limit=10');

          if (data.data && data.data.users) {
            const deleteResults = [];

            for (const user of data.data.users) {
              try {
                await apiRequest(`/users/${user.id}`, {
                  method: 'DELETE'
                });

                deleteResults.push({
                  userId: user.id,
                  username: user.username,
                  deleted: true,
                });
              } catch (error) {
                deleteResults.push({
                  userId: user.id,
                  username: user.username,
                  deleted: false,
                  error: error.message,
                });
              }
            }

            showResponse(
              'batchResponse',
              {
                operation: 'Batch User Deletion',
                results: deleteResults,
                deleted: deleteResults.filter(r => r.deleted).length,
              },
              'success'
            );

            refreshStats();
          }
        } catch (error) {
          showResponse('batchResponse', { error: error.message }, 'error');
        }
      }

      async function runPerformanceTest() {
        const iterations = 50;
        const results = {
          createUser: [],
          findUser: [],
          deleteUser: [],
        };

        showResponse('performanceResponse', { status: 'Running performance test...' }, 'success');

        // Test user creation performance
        const createStart = performance.now();
        for (let i = 0; i < iterations; i++) {
          const start = performance.now();
          try {
            await apiRequest('/users', {
              method: 'POST',
              body: JSON.stringify({
                username: `perf_${Date.now()}_${i}`,
                displayName: `Performance Test ${i}`,
              }),
            });
            results.createUser.push(performance.now() - start);
          } catch (error) {
            results.createUser.push(-1);
          }
        }
        const createEnd = performance.now();

        // Test user listing performance
        for (let i = 0; i < iterations; i++) {
          const start = performance.now();
          try {
            await apiRequest('/users');
            results.findUser.push(performance.now() - start);
          } catch (error) {
            results.findUser.push(-1);
          }
        }

        const stats = {
          test: 'Performance Test',
          iterations: iterations,
          createUser: {
            totalTime: createEnd - createStart,
            averageTime:
              results.createUser.filter(t => t > 0).reduce((a, b) => a + b, 0) /
              results.createUser.filter(t => t > 0).length,
            successful: results.createUser.filter(t => t > 0).length,
          },
          findUser: {
            averageTime:
              results.findUser.filter(t => t > 0).reduce((a, b) => a + b, 0) /
              results.findUser.filter(t => t > 0).length,
            successful: results.findUser.filter(t => t > 0).length,
          },
        };

        showResponse('performanceResponse', stats, 'success');
      }

      async function stressTestStorage() {
        const concurrentRequests = 20;
        const promises = [];

        showResponse('performanceResponse', { status: 'Running stress test...' }, 'success');

        const start = performance.now();

        for (let i = 0; i < concurrentRequests; i++) {
          promises.push(
            apiRequest('/users', {
              method: 'POST',
              body: JSON.stringify({
                username: `stress_${Date.now()}_${i}`,
                displayName: `Stress Test ${i}`,
              }),
            })
          );
        }

        try {
          const results = await Promise.allSettled(promises);
          const end = performance.now();
          const successful = results.filter(r => r.status === 'fulfilled').length;

          showResponse(
            'performanceResponse',
            {
              test: 'Stress Test',
              concurrentRequests: concurrentRequests,
              totalTime: end - start,
              successful: successful,
              failed: concurrentRequests - successful,
              successRate: `${((successful / concurrentRequests) * 100).toFixed(1)}%`,
            },
            'success'
          );

          refreshStats();
        } catch (error) {
          showResponse('performanceResponse', { error: error.message }, 'error');
        }
      }

      // HTTP Utilities testing
      async function testNotFound() {
        try {
          await apiRequest('/test/404');
        } catch (error) {
          showResponse('httpErrorResponse', { error: error.message }, 'error');
        }
      }

      async function testConflict() {
        try {
          await apiRequest('/test/409', {
            method: 'POST',
          });
        } catch (error) {
          showResponse('httpErrorResponse', { error: error.message }, 'error');
        }
      }

      async function testServerError() {
        // This would need a custom endpoint to trigger server error
        // For now, we'll show an example error response
        const exampleError = {
          error: {
            type: 'INTERNAL_ERROR',
            message: 'Internal server error',
            timestamp: new Date().toISOString(),
            requestId: 'req-' + Date.now(),
          },
        };
        showResponse(
          'httpErrorResponse',
          { example: exampleError, note: 'Example error response format' },
          'error'
        );
      }

      async function testServiceUnavailable() {
        try {
          await apiRequest('/test/503');
        } catch (error) {
          showResponse('httpErrorResponse', { error: error.message }, 'error');
        }
      }

      async function testValidationError() {
        try {
          await apiRequest('/test/validation', {
            method: 'POST',
          });
        } catch (error) {
          showResponse('httpValidationResponse', { error: error.message }, 'error');
        }
      }

      async function testAuthError() {
        try {
          await apiRequest('/test/auth');
        } catch (error) {
          showResponse('httpValidationResponse', { error: error.message }, 'error');
        }
      }

      async function analyzeRequests() {
        const analysis = {
          totalRequests: requestCount,
          successRate:
            requestCount > 0 ? ((successCount / requestCount) * 100).toFixed(1) + '%' : '0%',
          averageResponseTime: 'N/A (would need timing implementation)',
          endpoints: [
            { path: '/health', method: 'GET', description: 'Service health check' },
            { path: '/users', method: 'GET', description: 'List users (paginated)' },
            { path: '/users', method: 'POST', description: 'Create new user' },
            { path: '/users/:id', method: 'GET', description: 'Get user by ID' },
            { path: '/users/:id', method: 'DELETE', description: 'Delete user' },
          ],
        };
        showResponse('httpAnalysisResponse', analysis, 'success');
      }

      async function testResponseFormat() {
        const formats = {
          success: {
            message: 'Operation completed successfully',
            timestamp: new Date().toISOString(),
            data: { example: 'response data' },
          },
          error: {
            error: {
              type: 'ERROR_TYPE',
              message: 'Error description',
              timestamp: new Date().toISOString(),
              requestId: 'req-' + Date.now(),
            },
          },
          paginated: {
            data: [...Array(3)].map((_, i) => ({ id: i + 1, name: `Item ${i + 1}` })),
            pagination: {
              page: 1,
              limit: 10,
              total: 3,
              totalPages: 1,
            },
          },
        };
        showResponse('httpAnalysisResponse', formats, 'success');
      }

      // Stats and utilities
      function refreshStats() {
        checkServerHealth();
        updateRequestStats();
      }

      function updateRequestStats() {
        document.getElementById('totalRequests').textContent = requestCount;
        const rate = requestCount > 0 ? ((successCount / requestCount) * 100).toFixed(1) : '0';
        document.getElementById('successRate').textContent = rate + '%';
      }

      // API Service wrapper functions using our centralized service
      // Loading state management
      let isLoading = false;

      async function apiRequest(endpoint, options = {}) {
        if (isLoading) {
          console.warn('Request already in progress, ignoring duplicate call');
          return;
        }

        isLoading = true;
        updateLoadingStates(true);

        try {
          const response = await fetch(`${API_BASE}${endpoint}`, {
            headers: {
              'Content-Type': 'application/json',
              ...options.headers,
            },
            ...options,
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(
              errorData.error?.message ||
                errorData.message ||
                `HTTP ${response.status}: ${response.statusText}`
            );
          }

          return await response.json();
        } catch (error) {
          if (error instanceof Error) {
            throw error;
          }
          throw new Error('Network error occurred');
        } finally {
          isLoading = false;
          updateLoadingStates(false);
        }
      }

      function updateLoadingStates(loading) {
        const buttons = document.querySelectorAll('button');
        buttons.forEach(button => {
          if (loading) {
            button.disabled = true;
            button.style.opacity = '0.6';
          } else {
            button.disabled = false;
            button.style.opacity = '1';
          }
        });

        // Update status indicator
        const statusEl = document.getElementById('requestStatus');
        if (statusEl) {
          statusEl.textContent = loading ? '‚è≥ Processing...' : '‚úÖ Ready';
          statusEl.className = loading ? 'status-processing' : 'status-ready';
        }
      }

      // Health check endpoints
      async function getHealth() {
        return apiRequest('/health');
      }

      async function getServerInfo() {
        return apiRequest('/');
      }

      // User management endpoints
      async function getUsers(page = 1, limit = 10) {
        return apiRequest(`/users?page=${page}&limit=${limit}`);
      }

      async function createUser(userData) {
        return apiRequest('/users', {
          method: 'POST',
          body: JSON.stringify(userData),
        });
      }

      async function getUserById(id) {
        return apiRequest(`/users/${id}`);
      }

      async function getUserByUsername(username) {
        return apiRequest(`/users/by-username/${username}`);
      }

      async function updateUser(id, userData) {
        return apiRequest(`/users/${id}`, {
          method: 'PUT',
          body: JSON.stringify(userData),
        });
      }

      async function deleteUser(id) {
        return apiRequest(`/users/${id}`, {
          method: 'DELETE',
        });
      }

      async function clearAllUsers() {
        return apiRequest('/users/clear', {
          method: 'POST',
        });
      }

      function showResponse(elementId, data, type = 'info') {
        const element = document.getElementById(elementId);
        if (!element) {
          console.error(`Element with ID '${elementId}' not found`);
          return;
        }

        element.classList.remove('hidden', 'success', 'error');
        element.classList.add(type);
        element.textContent = JSON.stringify(data, null, 2);

        // Update request stats
        requestCount++;
        if (type === 'success') successCount++;
        updateRequestStats();
      }

      // ============ EMAIL UTILITIES ============
      async function testEmailValidation() {
        const email = document.getElementById('emailInput').value;
        if (!email) {
          showResponse('emailValidationResponse', { error: 'Please enter an email address' }, 'error');
          return;
        }
        try {
          const data = await apiRequest('/utils/email/validate', {
            method: 'POST',
            body: JSON.stringify({ email })
          });
          showResponse('emailValidationResponse', data, 'success');
        } catch (error) {
          showResponse('emailValidationResponse', { error: error.message }, 'error');
        }
      }

      async function testEmailNormalize() {
        const email = document.getElementById('emailInput').value;
        if (!email) {
          showResponse('emailValidationResponse', { error: 'Please enter an email address' }, 'error');
          return;
        }
        try {
          const data = await apiRequest('/utils/email/normalize', {
            method: 'POST',
            body: JSON.stringify({ email })
          });
          showResponse('emailValidationResponse', data, 'success');
        } catch (error) {
          showResponse('emailValidationResponse', { error: error.message }, 'error');
        }
      }

      async function testEmailDomain() {
        const email = document.getElementById('emailDomainInput').value;
        if (!email) {
          showResponse('emailDomainResponse', { error: 'Please enter an email address' }, 'error');
          return;
        }
        try {
          const data = await apiRequest('/utils/email/domain', {
            method: 'POST',
            body: JSON.stringify({ email })
          });
          showResponse('emailDomainResponse', data, 'success');
        } catch (error) {
          showResponse('emailDomainResponse', { error: error.message }, 'error');
        }
      }

      async function testFilterEmails() {
        const input = document.getElementById('emailListInput').value;
        if (!input) {
          showResponse('emailFilterResponse', { error: 'Please enter email addresses' }, 'error');
          return;
        }
        const emails = input.split(',').map(e => e.trim());
        try {
          const data = await apiRequest('/utils/email/filter', {
            method: 'POST',
            body: JSON.stringify({ emails })
          });
          showResponse('emailFilterResponse', data, 'success');
        } catch (error) {
          showResponse('emailFilterResponse', { error: error.message }, 'error');
        }
      }

      async function testCreateEmailTarget() {
        const name = document.getElementById('emailTargetName').value;
        const email = document.getElementById('emailTargetAddress').value;
        if (!email) {
          showResponse('emailTargetResponse', { error: 'Please enter an email address' }, 'error');
          return;
        }
        try {
          const data = await apiRequest('/utils/email/target', {
            method: 'POST',
            body: JSON.stringify({ name, email })
          });
          showResponse('emailTargetResponse', data, 'success');
        } catch (error) {
          showResponse('emailTargetResponse', { error: error.message }, 'error');
        }
      }

      // ============ MEMOIZATION ============
      async function testMemoizedFib() {
        const n = parseInt(document.getElementById('memoFibInput').value);
        try {
          const data = await apiRequest('/utils/memoize/fibonacci', {
            method: 'POST',
            body: JSON.stringify({ n, memoized: true })
          });
          showResponse('memoFibResponse', data, 'success');
        } catch (error) {
          showResponse('memoFibResponse', { error: error.message }, 'error');
        }
      }

      async function testUnmemoizedFib() {
        const n = parseInt(document.getElementById('memoFibInput').value);
        if (n > 35) {
          showResponse('memoFibResponse', { warning: 'Unmemoized calculation for n > 35 may be very slow' }, 'error');
          return;
        }
        try {
          const data = await apiRequest('/utils/memoize/fibonacci', {
            method: 'POST',
            body: JSON.stringify({ n, memoized: false })
          });
          showResponse('memoFibResponse', data, 'success');
        } catch (error) {
          showResponse('memoFibResponse', { error: error.message }, 'error');
        }
      }

      async function testMemoWithTTL() {
        const value = document.getElementById('memoTTLInput').value;
        const ttl = parseInt(document.getElementById('memoTTLDuration').value);
        try {
          const data = await apiRequest('/utils/memoize/ttl', {
            method: 'POST',
            body: JSON.stringify({ value, ttl })
          });
          showResponse('memoTTLResponse', data, 'success');
        } catch (error) {
          showResponse('memoTTLResponse', { error: error.message }, 'error');
        }
      }

      async function testMemoTTLExpiry() {
        try {
          const data = await apiRequest('/utils/memoize/ttl/check');
          showResponse('memoTTLResponse', data, 'success');
        } catch (error) {
          showResponse('memoTTLResponse', { error: error.message }, 'error');
        }
      }

      async function getMemoStats() {
        try {
          const data = await apiRequest('/utils/memoize/stats');
          showResponse('memoStatsResponse', data, 'success');
        } catch (error) {
          showResponse('memoStatsResponse', { error: error.message }, 'error');
        }
      }

      async function clearMemoCache() {
        try {
          const data = await apiRequest('/utils/memoize/clear', { method: 'POST' });
          showResponse('memoStatsResponse', data, 'success');
        } catch (error) {
          showResponse('memoStatsResponse', { error: error.message }, 'error');
        }
      }

      // ============ CIRCUIT BREAKER ============
      async function testCircuitBreaker() {
        const failureRate = parseInt(document.getElementById('cbFailureRate').value);
        try {
          const data = await apiRequest('/utils/circuit-breaker/test', {
            method: 'POST',
            body: JSON.stringify({ failureRate })
          });
          showResponse('circuitBreakerResponse', data, 'success');
        } catch (error) {
          showResponse('circuitBreakerResponse', { error: error.message }, 'error');
        }
      }

      async function triggerCircuitOpen() {
        try {
          const data = await apiRequest('/utils/circuit-breaker/trigger-open', { method: 'POST' });
          showResponse('circuitBreakerResponse', data, 'success');
        } catch (error) {
          showResponse('circuitBreakerResponse', { error: error.message }, 'error');
        }
      }

      async function getCircuitState() {
        try {
          const data = await apiRequest('/utils/circuit-breaker/state');
          showResponse('circuitStateResponse', data, 'success');
        } catch (error) {
          showResponse('circuitStateResponse', { error: error.message }, 'error');
        }
      }

      async function resetCircuit() {
        try {
          const data = await apiRequest('/utils/circuit-breaker/reset', { method: 'POST' });
          showResponse('circuitStateResponse', data, 'success');
        } catch (error) {
          showResponse('circuitStateResponse', { error: error.message }, 'error');
        }
      }

      async function createManagedBreaker() {
        const serviceName = document.getElementById('cbServiceName').value;
        try {
          const data = await apiRequest('/utils/circuit-breaker/factory/create', {
            method: 'POST',
            body: JSON.stringify({ serviceName })
          });
          showResponse('circuitFactoryResponse', data, 'success');
        } catch (error) {
          showResponse('circuitFactoryResponse', { error: error.message }, 'error');
        }
      }

      async function getFactoryStats() {
        try {
          const data = await apiRequest('/utils/circuit-breaker/factory/stats');
          showResponse('circuitFactoryResponse', data, 'success');
        } catch (error) {
          showResponse('circuitFactoryResponse', { error: error.message }, 'error');
        }
      }

      // ============ QUEUE MANAGEMENT ============
      async function testAsyncQueue() {
        const jobCount = parseInt(document.getElementById('queueJobCount').value);
        const concurrency = parseInt(document.getElementById('queueConcurrency').value);
        try {
          const data = await apiRequest('/utils/queue/async', {
            method: 'POST',
            body: JSON.stringify({ jobCount, concurrency })
          });
          showResponse('asyncQueueResponse', data, 'success');
        } catch (error) {
          showResponse('asyncQueueResponse', { error: error.message }, 'error');
        }
      }

      async function testConcurrencyLimiter() {
        const maxConcurrent = parseInt(document.getElementById('limiterMaxConcurrent').value);
        try {
          const data = await apiRequest('/utils/queue/concurrency-limiter', {
            method: 'POST',
            body: JSON.stringify({ maxConcurrent })
          });
          showResponse('concurrencyLimiterResponse', data, 'success');
        } catch (error) {
          showResponse('concurrencyLimiterResponse', { error: error.message }, 'error');
        }
      }

      async function startPeriodicTask() {
        const interval = parseInt(document.getElementById('periodicInterval').value);
        try {
          const data = await apiRequest('/utils/queue/periodic/start', {
            method: 'POST',
            body: JSON.stringify({ interval })
          });
          showResponse('periodicTaskResponse', data, 'success');
        } catch (error) {
          showResponse('periodicTaskResponse', { error: error.message }, 'error');
        }
      }

      async function stopPeriodicTask() {
        try {
          const data = await apiRequest('/utils/queue/periodic/stop', { method: 'POST' });
          showResponse('periodicTaskResponse', data, 'success');
        } catch (error) {
          showResponse('periodicTaskResponse', { error: error.message }, 'error');
        }
      }

      async function getActivePeriodicTasks() {
        try {
          const data = await apiRequest('/utils/queue/periodic/active');
          showResponse('periodicTaskResponse', data, 'success');
        } catch (error) {
          showResponse('periodicTaskResponse', { error: error.message }, 'error');
        }
      }

      async function getQueueState() {
        try {
          const data = await apiRequest('/utils/queue/state');
          showResponse('queueStateResponse', data, 'success');
        } catch (error) {
          showResponse('queueStateResponse', { error: error.message }, 'error');
        }
      }

      async function enforceQueueLimit() {
        try {
          const data = await apiRequest('/utils/queue/enforce-limit', { method: 'POST' });
          showResponse('queueStateResponse', data, 'success');
        } catch (error) {
          showResponse('queueStateResponse', { error: error.message }, 'error');
        }
      }

      // ============ FAST OPERATIONS ============
      async function testFastMath() {
        const a = parseFloat(document.getElementById('fastMathA').value);
        const b = parseFloat(document.getElementById('fastMathB').value);
        try {
          const data = await apiRequest('/utils/fast/math', {
            method: 'POST',
            body: JSON.stringify({ a, b })
          });
          showResponse('fastMathResponse', data, 'success');
        } catch (error) {
          showResponse('fastMathResponse', { error: error.message }, 'error');
        }
      }

      async function testFastString() {
        const input = document.getElementById('fastStringInput').value;
        try {
          const data = await apiRequest('/utils/fast/string', {
            method: 'POST',
            body: JSON.stringify({ input })
          });
          showResponse('fastStringResponse', data, 'success');
        } catch (error) {
          showResponse('fastStringResponse', { error: error.message }, 'error');
        }
      }

      async function testFastHash() {
        const input = document.getElementById('fastHashInput').value;
        try {
          const data = await apiRequest('/utils/fast/hash', {
            method: 'POST',
            body: JSON.stringify({ input })
          });
          showResponse('fastHashResponse', data, 'success');
        } catch (error) {
          showResponse('fastHashResponse', { error: error.message }, 'error');
        }
      }

      async function testObjectPool() {
        const poolSize = parseInt(document.getElementById('poolSize').value);
        try {
          const data = await apiRequest('/utils/fast/object-pool', {
            method: 'POST',
            body: JSON.stringify({ poolSize })
          });
          showResponse('objectPoolResponse', data, 'success');
        } catch (error) {
          showResponse('objectPoolResponse', { error: error.message }, 'error');
        }
      }

      async function testLockFreeQueue() {
        const operations = parseInt(document.getElementById('lfqOperations').value);
        try {
          const data = await apiRequest('/utils/fast/lock-free-queue', {
            method: 'POST',
            body: JSON.stringify({ operations })
          });
          showResponse('lockFreeQueueResponse', data, 'success');
        } catch (error) {
          showResponse('lockFreeQueueResponse', { error: error.message }, 'error');
        }
      }

      async function testFastTimer() {
        try {
          const data = await apiRequest('/utils/fast/timer');
          showResponse('fastTimerResponse', data, 'success');
        } catch (error) {
          showResponse('fastTimerResponse', { error: error.message }, 'error');
        }
      }

      // ============ PAGINATION ============
      async function testOffsetPagination() {
        const page = parseInt(document.getElementById('paginationPage').value);
        const limit = parseInt(document.getElementById('paginationLimit').value);
        const total = parseInt(document.getElementById('paginationTotal').value);
        try {
          const data = await apiRequest('/utils/pagination/offset', {
            method: 'POST',
            body: JSON.stringify({ page, limit, total })
          });
          showResponse('offsetPaginationResponse', data, 'success');
        } catch (error) {
          showResponse('offsetPaginationResponse', { error: error.message }, 'error');
        }
      }

      async function testCursorPagination() {
        const cursor = document.getElementById('cursorInput').value;
        const limit = parseInt(document.getElementById('cursorLimit').value);
        try {
          const data = await apiRequest('/utils/pagination/cursor', {
            method: 'POST',
            body: JSON.stringify({ cursor: cursor || null, limit })
          });
          showResponse('cursorPaginationResponse', data, 'success');
        } catch (error) {
          showResponse('cursorPaginationResponse', { error: error.message }, 'error');
        }
      }

      async function generateCursor() {
        try {
          const data = await apiRequest('/utils/pagination/cursor/generate', {
            method: 'POST',
            body: JSON.stringify({ id: 'sample-id-' + Date.now(), timestamp: new Date().toISOString() })
          });
          showResponse('cursorPaginationResponse', data, 'success');
          if (data.cursor) {
            document.getElementById('cursorInput').value = data.cursor;
          }
        } catch (error) {
          showResponse('cursorPaginationResponse', { error: error.message }, 'error');
        }
      }

      async function testSortingValidation() {
        const field = document.getElementById('sortField').value;
        const order = document.getElementById('sortOrder').value;
        try {
          const data = await apiRequest('/utils/pagination/sort/validate', {
            method: 'POST',
            body: JSON.stringify({ field, order })
          });
          showResponse('sortingValidationResponse', data, 'success');
        } catch (error) {
          showResponse('sortingValidationResponse', { error: error.message }, 'error');
        }
      }

      // ============ CACHE UTILITIES ============
      async function lruSet() {
        const key = document.getElementById('lruKey').value;
        const value = document.getElementById('lruValue').value;
        if (!key) {
          showResponse('lruCacheResponse', { error: 'Please enter a key' }, 'error');
          return;
        }
        try {
          const data = await apiRequest('/utils/cache/lru/set', {
            method: 'POST',
            body: JSON.stringify({ key, value })
          });
          showResponse('lruCacheResponse', data, 'success');
        } catch (error) {
          showResponse('lruCacheResponse', { error: error.message }, 'error');
        }
      }

      async function lruGet() {
        const key = document.getElementById('lruKey').value;
        if (!key) {
          showResponse('lruCacheResponse', { error: 'Please enter a key' }, 'error');
          return;
        }
        try {
          const data = await apiRequest(`/utils/cache/lru/get/${encodeURIComponent(key)}`);
          showResponse('lruCacheResponse', data, 'success');
        } catch (error) {
          showResponse('lruCacheResponse', { error: error.message }, 'error');
        }
      }

      async function lruDelete() {
        const key = document.getElementById('lruKey').value;
        if (!key) {
          showResponse('lruCacheResponse', { error: 'Please enter a key' }, 'error');
          return;
        }
        try {
          const data = await apiRequest(`/utils/cache/lru/delete/${encodeURIComponent(key)}`, {
            method: 'DELETE'
          });
          showResponse('lruCacheResponse', data, 'success');
        } catch (error) {
          showResponse('lruCacheResponse', { error: error.message }, 'error');
        }
      }

      async function testBoundedQueue() {
        const maxSize = parseInt(document.getElementById('bqMaxSize').value);
        const itemCount = parseInt(document.getElementById('bqItemCount').value);
        try {
          const data = await apiRequest('/utils/cache/bounded-queue', {
            method: 'POST',
            body: JSON.stringify({ maxSize, itemCount })
          });
          showResponse('boundedQueueResponse', data, 'success');
        } catch (error) {
          showResponse('boundedQueueResponse', { error: error.message }, 'error');
        }
      }

      async function testBoundedMap() {
        const maxSize = parseInt(document.getElementById('bmMaxSize').value);
        try {
          const data = await apiRequest('/utils/cache/bounded-map', {
            method: 'POST',
            body: JSON.stringify({ maxSize })
          });
          showResponse('boundedMapResponse', data, 'success');
        } catch (error) {
          showResponse('boundedMapResponse', { error: error.message }, 'error');
        }
      }

      async function getCacheMetrics() {
        try {
          const data = await apiRequest('/utils/cache/metrics');
          showResponse('cacheMetricsResponse', data, 'success');
        } catch (error) {
          showResponse('cacheMetricsResponse', { error: error.message }, 'error');
        }
      }

      async function resetCacheMetrics() {
        try {
          const data = await apiRequest('/utils/cache/metrics/reset', { method: 'POST' });
          showResponse('cacheMetricsResponse', data, 'success');
        } catch (error) {
          showResponse('cacheMetricsResponse', { error: error.message }, 'error');
        }
      }

      async function testMemoryOptimizedCache() {
        const maxItems = parseInt(document.getElementById('mocMaxItems').value);
        try {
          const data = await apiRequest('/utils/cache/memory-optimized', {
            method: 'POST',
            body: JSON.stringify({ maxItems })
          });
          showResponse('memoryOptimizedCacheResponse', data, 'success');
        } catch (error) {
          showResponse('memoryOptimizedCacheResponse', { error: error.message }, 'error');
        }
      }

      async function getMemoryCacheStats() {
        try {
          const data = await apiRequest('/utils/cache/memory-optimized/stats');
          showResponse('memoryOptimizedCacheResponse', data, 'success');
        } catch (error) {
          showResponse('memoryOptimizedCacheResponse', { error: error.message }, 'error');
        }
      }

      // ============ STREAMING ============
      async function testSafeJsonParse() {
        const input = document.getElementById('jsonInput').value;
        try {
          const data = await apiRequest('/utils/streaming/json/parse', {
            method: 'POST',
            body: JSON.stringify({ input })
          });
          showResponse('safeJsonResponse', data, 'success');
        } catch (error) {
          showResponse('safeJsonResponse', { error: error.message }, 'error');
        }
      }

      async function testSafeJsonStringify() {
        const input = document.getElementById('jsonInput').value;
        try {
          const parsed = JSON.parse(input);
          const data = await apiRequest('/utils/streaming/json/stringify', {
            method: 'POST',
            body: JSON.stringify({ input: parsed })
          });
          showResponse('safeJsonResponse', data, 'success');
        } catch (error) {
          showResponse('safeJsonResponse', { error: error.message }, 'error');
        }
      }

      async function testChunkedProcessing() {
        const dataSize = parseInt(document.getElementById('chunkDataSize').value);
        const chunkSize = parseInt(document.getElementById('chunkSize').value);
        try {
          const data = await apiRequest('/utils/streaming/chunked', {
            method: 'POST',
            body: JSON.stringify({ dataSize, chunkSize })
          });
          showResponse('chunkedProcessingResponse', data, 'success');
        } catch (error) {
          showResponse('chunkedProcessingResponse', { error: error.message }, 'error');
        }
      }

      async function testLineStreamProcessing() {
        const input = document.getElementById('lineStreamInput').value;
        try {
          const data = await apiRequest('/utils/streaming/lines', {
            method: 'POST',
            body: JSON.stringify({ input })
          });
          showResponse('lineStreamResponse', data, 'success');
        } catch (error) {
          showResponse('lineStreamResponse', { error: error.message }, 'error');
        }
      }

      // ============ FIELD UTILITIES ============
      async function testNormalizeField() {
        const fieldName = document.getElementById('fieldNameInput').value;
        if (!fieldName) {
          showResponse('fieldNormalizeResponse', { error: 'Please enter a field name' }, 'error');
          return;
        }
        try {
          const data = await apiRequest('/utils/fields/normalize', {
            method: 'POST',
            body: JSON.stringify({ fieldName })
          });
          showResponse('fieldNormalizeResponse', data, 'success');
        } catch (error) {
          showResponse('fieldNormalizeResponse', { error: error.message }, 'error');
        }
      }

      async function testDenormalizeField() {
        const fieldName = document.getElementById('fieldNameInput').value;
        if (!fieldName) {
          showResponse('fieldNormalizeResponse', { error: 'Please enter a field name' }, 'error');
          return;
        }
        try {
          const data = await apiRequest('/utils/fields/denormalize', {
            method: 'POST',
            body: JSON.stringify({ fieldName })
          });
          showResponse('fieldNormalizeResponse', data, 'success');
        } catch (error) {
          showResponse('fieldNormalizeResponse', { error: error.message }, 'error');
        }
      }

      async function testNormalizeObjectFields() {
        const input = document.getElementById('objectFieldsInput').value;
        try {
          const obj = JSON.parse(input);
          const data = await apiRequest('/utils/fields/normalize-object', {
            method: 'POST',
            body: JSON.stringify({ object: obj })
          });
          showResponse('objectFieldsResponse', data, 'success');
        } catch (error) {
          showResponse('objectFieldsResponse', { error: error.message }, 'error');
        }
      }

      async function testDenormalizeObjectFields() {
        const input = document.getElementById('objectFieldsInput').value;
        try {
          const obj = JSON.parse(input);
          const data = await apiRequest('/utils/fields/denormalize-object', {
            method: 'POST',
            body: JSON.stringify({ object: obj })
          });
          showResponse('objectFieldsResponse', data, 'success');
        } catch (error) {
          showResponse('objectFieldsResponse', { error: error.message }, 'error');
        }
      }

      async function testGetCollectionName() {
        const modelName = document.getElementById('modelNameInput').value;
        if (!modelName) {
          showResponse('collectionNameResponse', { error: 'Please enter a model name' }, 'error');
          return;
        }
        try {
          const data = await apiRequest('/utils/fields/collection-name', {
            method: 'POST',
            body: JSON.stringify({ modelName })
          });
          showResponse('collectionNameResponse', data, 'success');
        } catch (error) {
          showResponse('collectionNameResponse', { error: error.message }, 'error');
        }
      }

      async function testGetMongoType() {
        const typeName = document.getElementById('typeMapInput').value;
        try {
          const data = await apiRequest('/utils/fields/mongo-type', {
            method: 'POST',
            body: JSON.stringify({ typeName })
          });
          showResponse('typeMapResponse', data, 'success');
        } catch (error) {
          showResponse('typeMapResponse', { error: error.message }, 'error');
        }
      }

      async function testGetSupportedTypes() {
        try {
          const data = await apiRequest('/utils/fields/supported-types');
          showResponse('typeMapResponse', data, 'success');
        } catch (error) {
          showResponse('typeMapResponse', { error: error.message }, 'error');
        }
      }

      async function testSerializeDocument() {
        const input = document.getElementById('serializeInput').value;
        try {
          const doc = JSON.parse(input);
          const data = await apiRequest('/utils/fields/serialize', {
            method: 'POST',
            body: JSON.stringify({ document: doc })
          });
          showResponse('serializeResponse', data, 'success');
        } catch (error) {
          showResponse('serializeResponse', { error: error.message }, 'error');
        }
      }

      async function testSerializeWithoutFields() {
        const input = document.getElementById('serializeInput').value;
        try {
          const doc = JSON.parse(input);
          const data = await apiRequest('/utils/fields/serialize-without', {
            method: 'POST',
            body: JSON.stringify({ document: doc, excludeFields: ['__v', '_id'] })
          });
          showResponse('serializeResponse', data, 'success');
        } catch (error) {
          showResponse('serializeResponse', { error: error.message }, 'error');
        }
      }

      // ============ SECURITY ============
      async function testRateLimiter() {
        const requests = parseInt(document.getElementById('rateLimitRequests').value);
        const results = [];
        for (let i = 0; i < requests; i++) {
          try {
            const data = await apiRequest('/utils/security/rate-limit-test');
            results.push({ request: i + 1, status: 'allowed', data });
          } catch (error) {
            results.push({ request: i + 1, status: 'blocked', error: error.message });
          }
        }
        showResponse('rateLimiterResponse', {
          totalRequests: requests,
          allowed: results.filter(r => r.status === 'allowed').length,
          blocked: results.filter(r => r.status === 'blocked').length,
          results: results.slice(-10)
        }, 'success');
      }

      async function getSecurityHeaders() {
        try {
          const response = await fetch(`${API_BASE}/utils/security/headers`);
          const headers = {};
          response.headers.forEach((value, key) => {
            headers[key] = value;
          });
          showResponse('securityHeadersResponse', { headers }, 'success');
        } catch (error) {
          showResponse('securityHeadersResponse', { error: error.message }, 'error');
        }
      }

      async function testHelmetConfig() {
        try {
          const data = await apiRequest('/utils/security/helmet-config');
          showResponse('securityHeadersResponse', data, 'success');
        } catch (error) {
          showResponse('securityHeadersResponse', { error: error.message }, 'error');
        }
      }

      async function testPrivacyHeaders() {
        try {
          const data = await apiRequest('/utils/security/privacy-headers');
          showResponse('privacyComplianceResponse', data, 'success');
        } catch (error) {
          showResponse('privacyComplianceResponse', { error: error.message }, 'error');
        }
      }

      async function testCCPACompliance() {
        try {
          const data = await apiRequest('/utils/security/ccpa-compliance');
          showResponse('privacyComplianceResponse', data, 'success');
        } catch (error) {
          showResponse('privacyComplianceResponse', { error: error.message }, 'error');
        }
      }

      async function testDataExport() {
        const userId = document.getElementById('dataUserId').value;
        if (!userId) {
          showResponse('dataManagementResponse', { error: 'Please enter a user ID' }, 'error');
          return;
        }
        try {
          const data = await apiRequest('/utils/security/data-export', {
            method: 'POST',
            body: JSON.stringify({ userId })
          });
          showResponse('dataManagementResponse', data, 'success');
        } catch (error) {
          showResponse('dataManagementResponse', { error: error.message }, 'error');
        }
      }

      async function testDataDeletion() {
        const userId = document.getElementById('dataUserId').value;
        if (!userId) {
          showResponse('dataManagementResponse', { error: 'Please enter a user ID' }, 'error');
          return;
        }
        if (!confirm('This will simulate a data deletion request. Continue?')) return;
        try {
          const data = await apiRequest('/utils/security/data-deletion', {
            method: 'POST',
            body: JSON.stringify({ userId })
          });
          showResponse('dataManagementResponse', data, 'success');
        } catch (error) {
          showResponse('dataManagementResponse', { error: error.message }, 'error');
        }
      }
    </script>
  </body>
</html>
