/**
 * In-Memory Storage Module
 *
 * This module provides a volatile in-memory storage system for user management.
 * It's designed for development, testing, and rapid prototyping scenarios where
 * persistent database storage is not required or desired.
 *
 * Key Features:
 * - Fast in-memory user storage with O(1) lookup by ID
 * - Username indexing for quick username-based queries
 * - Configurable user capacity limits
 * - Comprehensive error handling and logging
 * - Input validation and sanitization
 * - Automatic ID generation
 *
 * Limitations:
 * - Data is lost when application restarts (volatile)
 * - Not suitable for production use
 * - Single-process only (no distributed access)
 * - Memory usage scales with user count
 *
 * Security Considerations:
 * - All input is validated and sanitized
 * - Username conflicts are prevented
 * - Capacity limits prevent memory exhaustion
 * - Error logging for debugging and monitoring
 */

import qerrors from 'qerrors';

/**
 * Interface representing a complete user record in storage
 *
 * This interface defines the structure of user records stored in the
 * in-memory storage system. All fields are optional except for the
 * required ID and username fields.
 */
export interface User {
  id: number; // Unique numeric identifier (auto-generated)
  username: string; // Unique username (trimmed and validated)
  displayName: string | null; // Optional display name for UI purposes
  githubId: string | null; // Optional GitHub user ID for integration
  avatar: string | null; // Optional avatar URL for profile images
}

/**
 * Interface for user creation/insertion operations
 *
 * This interface defines the structure for creating new users.
 * The ID field is excluded as it's auto-generated by the storage system.
 * All other fields match the User interface but are optional.
 */
export interface InsertUser {
  username: string; // Required username (will be validated and trimmed)
  displayName?: string | null; // Optional display name
  githubId?: string | null; // Optional GitHub ID
  avatar?: string | null; // Optional avatar URL
}

/**
 * In-memory user storage class with capacity limits and indexing
 *
 * This class provides a complete user management system in memory with
 * dual indexing (by ID and username) for optimal performance. It includes
 * comprehensive validation, error handling, and capacity management.
 *
 * Performance Characteristics:
 * - O(1) lookup by user ID (Map-based)
 * - O(1) lookup by username (Map-based index)
 * - O(1) insertion and deletion
 * - Memory usage scales linearly with user count
 *
 * Data Structures:
 * - users: Map<id, User> - Primary storage by ID
 * - usernameIndex: Map<username, id> - Secondary index for username lookups
 * - currentId: Auto-incrementing ID generator
 * - maxUsers: Configurable capacity limit
 */
export class MemStorage {
  private users: Map<number, User>; // Primary storage indexed by user ID
  private usernameIndex: Map<string, number>; // Secondary index for username lookups
  private currentId: number; // Auto-incrementing ID generator
  private maxUsers: number; // Maximum user capacity limit

  /**
   * Creates a new in-memory storage instance
   *
   * Initializes the storage system with configurable capacity limits.
   * Validates the capacity parameter and sets up the internal data structures.
   *
   * @param maxUsers - Maximum number of users to store (default: 10000)
   * @throws {Error} When maxUsers is not a positive integer
   */
  constructor(maxUsers: number = 10000) {
    // Validate capacity parameter to prevent configuration errors
    if (typeof maxUsers !== 'number' || !Number.isInteger(maxUsers) || maxUsers <= 0)
      throw new Error('maxUsers must be a positive integer');

    // Initialize internal data structures
    this.users = new Map(); // Primary user storage
    this.usernameIndex = new Map(); // Username index for fast lookups
    this.currentId = 1; // Start ID generation at 1
    this.maxUsers = maxUsers; // Store capacity limit
  }

  /**
   * Retrieves a user by their numeric ID
   *
   * This method provides O(1) lookup performance for user retrieval by ID.
   * It includes input validation and comprehensive error handling. Invalid IDs
   * return undefined rather than throwing errors for graceful degradation.
   *
   * @param id - Numeric user ID to retrieve
   * @returns {Promise<User | undefined>} User record if found, undefined if not found or invalid
   * @throws {Error} When unexpected storage errors occur (logged via qerrors)
   */
  getUser = async (id: number): Promise<User | undefined> => {
    try {
      // Validate ID parameter - must be positive integer
      return typeof id !== 'number' || id < 1 ? undefined : this.users.get(id);
    } catch (error) {
      // Log unexpected errors for debugging and monitoring
      qerrors.qerrors(error as Error, 'storage.getUser', { id, operation: 'get' });
      throw error; // Re-throw for caller handling
    }
  };

  /**
   * Retrieves a user by their username (case-sensitive)
   *
   * This method provides O(1) lookup performance for user retrieval by username
   * using the secondary index. It includes input validation, username trimming,
   * and comprehensive error handling. Invalid usernames return undefined.
   *
   * @param username - Username to retrieve (will be trimmed for lookup)
   * @returns {Promise<User | undefined>} User record if found, undefined if not found or invalid
   * @throws {Error} When unexpected storage errors occur (logged via qerrors)
   */
  getUserByUsername = async (username: string): Promise<User | undefined> => {
    try {
      // Validate username parameter - must be non-empty string
      if (typeof username !== 'string' || !username.trim().length) return undefined;

      const trimmedUsername = username.trim(); // Normalize username for consistent lookup
      const userId = this.usernameIndex.get(trimmedUsername); // Look up ID by username

      // Return user record if found, undefined if not found
      return userId !== undefined ? this.users.get(userId) : undefined;
    } catch (error) {
      // Log unexpected errors with sanitized username for security
      qerrors.qerrors(error as Error, 'storage.getUserByUsername', {
        username: typeof username === 'string' ? username.trim() : username,
        operation: 'getByUsername',
      });
      throw error; // Re-throw for caller handling
    }
  };

  /**
   * Normalizes and validates user field data
   *
   * This private helper method processes user input data by trimming the username
   * and converting undefined optional fields to null values for consistent storage.
   * It ensures all user records have a consistent structure.
   *
   * @param insertUser - User input data to normalize
   * @returns {Omit<User, 'id'>} Normalized user data without ID field
   * @private
   */
  private normalizeUserFields = (insertUser: InsertUser): Omit<User, 'id'> => ({
    username: insertUser.username.trim(), // Trim username for consistent storage
    displayName: insertUser.displayName ?? null, // Convert undefined to null
    githubId: insertUser.githubId ?? null, // Convert undefined to null
    avatar: insertUser.avatar ?? null, // Convert undefined to null
  });

  /**
   * Creates a new user record with validation and conflict checking
   *
   * This method creates a new user with comprehensive validation including:
   * - Required field validation (username)
   * - Capacity limit checking
   * - Username uniqueness verification
   * - Input sanitization and normalization
   *
   * The method maintains both the primary storage and username index
   * to ensure data consistency across all lookup methods.
   *
   * @param insertUser - User data to create (username is required)
   * @returns {Promise<User>} Complete user record with auto-generated ID
   * @throws {Error} When validation fails, capacity exceeded, or username conflict occurs
   */
  createUser = async (insertUser: InsertUser): Promise<User> => {
    try {
      // Validate required username field
      if (
        !insertUser ||
        typeof insertUser.username !== 'string' ||
        !insertUser.username.trim().length
      )
        throw new Error('Username is required and must be a non-empty string');

      const trimmedUsername = insertUser.username.trim();

      // Check capacity limits to prevent memory exhaustion
      if (this.users.size >= this.maxUsers) throw new Error('Maximum user limit reached');

      // Verify username uniqueness to prevent conflicts
      const existingUser = await this.getUserByUsername(trimmedUsername);
      if (existingUser) throw new Error(`Username '${trimmedUsername}' already exists`);

      // Generate unique ID and normalize user data
      const id = this.currentId++; // Auto-increment ID generation
      const normalizedFields = this.normalizeUserFields({
        ...insertUser,
        username: trimmedUsername,
      });

      // Create complete user record
      const user = { id, ...normalizedFields };

      // Store in both primary storage and username index for consistency
      this.users.set(id, user); // Primary storage by ID
      this.usernameIndex.set(trimmedUsername, id); // Secondary index by username

      return user; // Return complete user record
    } catch (error) {
      // Log creation errors with context for debugging
      qerrors.qerrors(error as Error, 'storage.createUser', {
        username: insertUser?.username,
        currentUsers: this.users.size,
        maxUsers: this.maxUsers,
        hasDisplayName: insertUser?.displayName !== undefined,
      });
      throw error; // Re-throw for caller handling
    }
  };

  /**
   * Retrieves all users stored in the system
   *
   * This method returns a complete array of all user records. It's primarily
   * used for administrative purposes and testing. For large user bases,
   * consider implementing pagination to avoid memory issues.
   *
   * Performance Note: This method creates a new array from the Map values,
   * which has O(n) time complexity and memory usage proportional to the
   * number of stored users.
   *
   * @returns {Promise<User[]>} Array of all user records (empty array if no users)
   * @throws {Error} When unexpected storage errors occur (logged via qerrors)
   */
  getAllUsers = async (): Promise<User[]> => {
    try {
      // Convert Map values to array for complete user listing
      return Array.from(this.users.values());
    } catch (error) {
      // Log unexpected errors with user count context
      qerrors.qerrors(error as Error, 'storage.getAllUsers', {
        userCount: this.users.size,
        operation: 'getAll',
      });
      throw error; // Re-throw for caller handling
    }
  };

  /**
   * Updates an existing user record with validation and conflict checking
   *
   * This method updates user data with comprehensive validation including:
   * - ID validation and existence checking
   * - Username uniqueness verification (if username is being changed)
   * - Input sanitization and normalization
   * - Index maintenance for username changes
   *
   * The method maintains data consistency across both primary storage
   * and the username index when usernames are changed.
   *
   * @param id - Numeric ID of the user to update
   * @param updates - Partial user data to update (all fields optional)
   * @returns {Promise<User | undefined>} Updated user record or undefined if not found
   * @throws {Error} When username conflict occurs or validation fails
   */
  updateUser = async (id: number, updates: Partial<InsertUser>): Promise<User | undefined> => {
    try {
      // Validate ID parameter
      if (typeof id !== 'number' || id < 1) return undefined;

      // Check if user exists
      const existingUser = this.users.get(id);
      if (!existingUser) return undefined;

      // Handle username change with conflict checking
      if (updates.username && updates.username.trim() !== existingUser.username) {
        const trimmedUsername = updates.username.trim();

        // Check for username conflict with existing users
        const existingUserWithSameName = await this.getUserByUsername(trimmedUsername);
        if (existingUserWithSameName) {
          throw new Error(`Username '${trimmedUsername}' already exists`);
        }

        // Update username index when username changes
        this.usernameIndex.delete(existingUser.username); // Remove old username
        this.usernameIndex.set(trimmedUsername, id); // Add new username
      }

      // Create updated user record with merged data
      const updatedUser: User = {
        ...existingUser,
        ...updates,
        username: updates.username ? updates.username.trim() : existingUser.username,
      };

      // Store updated record in primary storage
      this.users.set(id, updatedUser);
      return updatedUser; // Return updated user record
    } catch (error) {
      // Log update errors with context for debugging
      qerrors.qerrors(error as Error, 'storage.updateUser', {
        id,
        updateFieldKeys: Object.keys(updates),
        hasUsernameUpdate: updates.username !== undefined,
        currentUsers: this.users.size,
      });
      throw error; // Re-throw for caller handling
    }
  };

  /**
   * Deletes a user record by ID with index cleanup
   *
   * This method removes a user from both the primary storage and the username
   * index to maintain data consistency. It includes ID validation and
   * returns a boolean indicating success for graceful error handling.
   *
   * Data Consistency: The method ensures that both the primary storage
   * and username index are updated atomically to prevent orphaned
   * index entries that could cause lookup failures.
   *
   * @param id - Numeric ID of the user to delete
   * @returns {Promise<boolean>} True if user was deleted, false if not found or invalid ID
   * @throws {Error} When unexpected storage errors occur (logged via qerrors)
   */
  deleteUser = async (id: number): Promise<boolean> => {
    try {
      // Validate ID parameter
      if (typeof id !== 'number' || id < 1) return false;

      // Get user record before deletion for index cleanup
      const user = this.users.get(id);
      if (user) {
        // Remove username from index to maintain consistency
        this.usernameIndex.delete(user.username);
      }

      // Remove from primary storage and return deletion result
      return this.users.delete(id);
    } catch (error) {
      // Log deletion errors for debugging
      qerrors.qerrors(error as Error, 'storage.deleteUser', { id, operation: 'delete' });
      throw error; // Re-throw for caller handling
    }
  };

  /**
   * Clears all user data and resets the storage system
   *
   * This method performs a complete reset of the storage system by:
   * - Clearing all user records from primary storage
   * - Clearing the username index
   * - Resetting the ID generator to 1
   *
   * This is typically used for testing purposes or when reinitializing
   * the storage system. All data is permanently lost.
   *
   * @returns {Promise<void>} Completes when storage is fully reset
   * @throws {Error} When unexpected storage errors occur (logged via qerrors)
   */
  clear = async (): Promise<void> => {
    try {
      this.users.clear(); // Clear primary storage
      this.usernameIndex.clear(); // Clear username index
      this.currentId = 1; // Reset ID generator
    } catch (error) {
      // Log clear errors with user count context
      qerrors.qerrors(error as Error, 'storage.clear', {
        userCount: this.users.size,
        operation: 'clear',
      });
      throw error; // Re-throw for caller handling
    }
  };
}

/**
 * Default singleton storage instance
 *
 * This exported instance provides immediate access to a ready-to-use
 * storage system without requiring manual instantiation. It uses the
 * default capacity limit of 10,000 users and is suitable for most
 * development and testing scenarios.
 *
 * Usage:
 * ```typescript
 * import { storage } from './storage';
 * const user = await storage.createUser({ username: 'alice' });
 * ```
 */
const storage = new MemStorage();
export { storage };
