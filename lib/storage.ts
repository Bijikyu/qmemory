/**
 * Storage Implementations
 *
 * Provides in-memory storage mechanisms for user data with comprehensive CRUD operations.
 * This module is designed for development, testing, and demo scenarios where a persistent
 * database is not required. It offers type-safe operations, validation, and error handling.
 *
 * Design Philosophy:
 * - Type safety: Full TypeScript support with interfaces for all data structures
 * - Validation: Input validation for all operations to prevent data corruption
 * - Error handling: Comprehensive error logging with qerrors integration
 * - Performance: O(1) lookups using Map data structure for user retrieval by ID
 * - Capacity management: Configurable limits to prevent memory exhaustion
 * - Consistency: Enforced uniqueness constraints on usernames
 *
 * Use Cases:
 * - Development environments without database setup
 * - Unit testing with predictable data state
 * - Demo applications requiring fast setup
 * - Prototyping with simple data persistence
 *
 * Limitations:
 * - Volatile storage: Data lost on application restart
 * - Single-process: No support for distributed scenarios
 * - Memory constraints: Limited by configured maximum users
 * - No query capabilities: Only supports basic CRUD operations
 */
import qerrors from 'qerrors';

/**
 * User record persisted within the in-memory storage system.
 *
 * Represents a complete user entity with all fields populated. The ID field
 * is auto-generated by the storage system and should not be manually assigned.
 * Optional fields use null instead of undefined to maintain consistency with
 * database storage patterns.
 *
 * @interface User
 */
export interface User {
  /** Auto-generated unique identifier for the user */
  id: number;
  /** Unique username for authentication and display (required) */
  username: string;
  /** Optional display name for user interface presentation */
  displayName: string | null;
  /** Optional GitHub OAuth identifier for social login integration */
  githubId: string | null;
  /** Optional avatar URL or path for profile image display */
  avatar: string | null;
}

/**
 * Payload accepted when inserting a new user record.
 *
 * Defines the contract for creating new users. Only the username is required,
 * while other fields are optional to support flexible user registration scenarios.
 * This interface enables partial user creation with subsequent profile completion.
 *
 * @interface InsertUser
 */
export interface InsertUser {
  /** Required unique username - will be trimmed and validated for uniqueness */
  username: string;
  /** Optional display name for user interface presentation */
  displayName?: string | null;
  /** Optional GitHub OAuth identifier for social login integration */
  githubId?: string | null;
  /** Optional avatar URL or path for profile image display */
  avatar?: string | null;
}

/**
 * Developer-friendly in-memory storage used for demos and unit tests.
 *
 * This class provides a complete CRUD interface for user management with
 * built-in validation, error handling, and capacity constraints. It uses a
 * Map data structure for O(1) performance on ID-based lookups and maintains
 * an auto-incrementing ID system for unique user identification.
 *
 * Features:
 * - O(1) user lookup by ID using Map data structure
 * - Auto-incrementing ID generation for unique identifiers
 * - Configurable capacity limits to prevent memory exhaustion
 * - Username uniqueness enforcement with case-sensitive comparison
 * - Comprehensive input validation and sanitization
 * - Error logging integration with qerrors system
 * - Atomic operations to prevent data corruption
 *
 * Thread Safety: This class is not thread-safe and should only be used in
 * single-process scenarios. For multi-threaded environments, external
 * synchronization is required.
 *
 * @class MemStorage
 */
export class MemStorage {
  /** Internal storage mapping user IDs to user entities for O(1) lookup performance */
  private users: Map<number, User>;
  /** Username index for O(1) username lookups to prevent linear search */
  private usernameIndex: Map<string, number>;
  /** Auto-incrementing counter for generating unique user IDs */
  private currentId: number;
  /** Maximum number of users allowed to prevent memory exhaustion */
  private maxUsers: number;

  /**
   * Initializes a new in-memory storage instance with configurable capacity.
   *
   * The constructor validates the maximum user limit and initializes internal
   * data structures. It throws errors for invalid configurations to prevent
   * runtime issues during operation.
   *
   * @param maxUsers - Upper bound enforced to protect development environments.
   *                   Must be a positive integer. Defaults to 10,000 users.
   *
   * @throws {Error} When maxUsers is not a positive integer.
   *
   * @example
   * ```typescript
   * const storage = new MemStorage(); // Default 10,000 user limit
   * const smallStorage = new MemStorage(100); // Limited to 100 users
   * ```
   */
  constructor(maxUsers: number = 10000) {
    console.log(`constructor is running with ${maxUsers}`);
    // Validate input to prevent configuration errors
    if (typeof maxUsers !== 'number' || !Number.isInteger(maxUsers) || maxUsers <= 0)
      throw new Error('maxUsers must be a positive integer'); // validation prevents memory issues
    this.users = new Map(); // using Map for O(1) lookups by ID
    this.usernameIndex = new Map(); // username index for O(1) lookups
    this.currentId = 1; // auto-incrementing ID generator
    this.maxUsers = maxUsers; // memory usage limit for development safety
    console.log(`constructor has run resulting in a final value of ${this.maxUsers}`);
  }

  /**
   * Retrieves a user by numeric identifier with validation and error handling.
   *
   * This method performs direct Map lookup for O(1) performance. It validates the
   * input ID to ensure it's a positive integer before attempting retrieval. The
   * method returns undefined for invalid IDs or when the user is not found,
   * maintaining consistency with standard JavaScript Map behavior.
   *
   * @param id - Auto-incremented identifier assigned to the user. Must be a positive integer.
   * @returns Stored user entity when found, undefined when ID is invalid or user doesn't exist.
   *
   * @throws {Error} When an unexpected error occurs during the lookup operation.
   *
   * @example
   * ```typescript
   * const user = await storage.getUser(1); // Returns user or undefined
   * const invalid = await storage.getUser(-1); // Returns undefined
   * ```
   */
  getUser = async (id: number): Promise<User | undefined> => {
    try {
      return typeof id !== 'number' || id < 1 ? undefined : this.users.get(id); // direct Map lookup for performance
    } catch (error) {
      qerrors.qerrors(error as Error, 'storage.getUser', {
        id,
        operation: 'get',
      });
      throw error; // Re-throw to preserve error propagation
    }
  };

  /**
   * Retrieves a user by username, trimming whitespace for consistency.
   *
   * @param username - Username to match against existing records.
   * @returns Stored user or undefined when not found.
   */
  getUserByUsername = async (username: string): Promise<User | undefined> => {
    try {
      if (typeof username !== 'string' || !username.trim().length) {
        return undefined;
      }
      const trimmedUsername = username.trim();
      const userId = this.usernameIndex.get(trimmedUsername);
      return userId !== undefined ? this.users.get(userId) : undefined;
    } catch (error) {
      qerrors.qerrors(error as Error, 'storage.getUserByUsername', {
        username: typeof username === 'string' ? username.trim() : username,
        operation: 'getByUsername',
      });
      throw error; // Re-throw to preserve error propagation
    }
  };

  private normalizeUserFields = (insertUser: InsertUser): Omit<User, 'id'> => ({
    username: insertUser.username.trim(),
    displayName: insertUser.displayName ?? null,
    githubId: insertUser.githubId ?? null,
    avatar: insertUser.avatar ?? null,
  });

  /**
   * Creates a new user, enforcing uniqueness and maximum capacity rules.
   *
   * @param insertUser - Candidate user payload.
   * @returns Persisted user record with generated identifier.
   */
  createUser = async (insertUser: InsertUser): Promise<User> => {
    try {
      if (
        !insertUser ||
        typeof insertUser.username !== 'string' ||
        !insertUser.username.trim().length
      )
        throw new Error('Username is required and must be a non-empty string');
      const trimmedUsername = insertUser.username.trim(); // consistent storage prevents spacing issues
      if (this.users.size >= this.maxUsers) throw new Error('Maximum user limit reached');
      const existingUser = await this.getUserByUsername(trimmedUsername);
      if (existingUser) throw new Error(`Username '${trimmedUsername}' already exists`); // uniqueness constraint
      const id = this.currentId++; // atomic increment ensures unique IDs
      const normalizedFields = this.normalizeUserFields({
        ...insertUser,
        username: trimmedUsername,
      });
      const user = { id, ...normalizedFields }; // spread operator combines ID with normalized fields
      this.users.set(id, user); // Map storage for O(1) retrieval
      this.usernameIndex.set(trimmedUsername, id); // Update username index for O(1) lookups
      return user;
    } catch (error) {
      qerrors.qerrors(error as Error, 'storage.createUser', {
        username: insertUser?.username,
        currentUsers: this.users.size,
        maxUsers: this.maxUsers,
        hasDisplayName: insertUser?.displayName !== undefined,
      });
      throw error;
    }
  };

  /**
   * @returns Snapshot of the current users stored in memory.
   */
  getAllUsers = async (): Promise<User[]> => {
    try {
      return Array.from(this.users.values());
    } catch (error) {
      qerrors.qerrors(error as Error, 'storage.getAllUsers', {
        userCount: this.users.size,
        operation: 'getAll',
      });
      throw error; // Re-throw to preserve error propagation
    }
  };

  /**
   * Updates a user record by identifier.
   *
   * @param id - Identifier to update.
   * @param updates - Partial user data to update.
   * @returns Updated user or undefined when not found.
   */
  updateUser = async (id: number, updates: Partial<InsertUser>): Promise<User | undefined> => {
    try {
      if (typeof id !== 'number' || id < 1) return undefined;
      const existingUser = this.users.get(id);
      if (!existingUser) return undefined;

      // Check for username conflict if username is being updated
      if (updates.username && updates.username.trim() !== existingUser.username) {
        const trimmedUsername = updates.username.trim();
        const existingUserWithSameName = await this.getUserByUsername(trimmedUsername);
        if (existingUserWithSameName) {
          throw new Error(`Username '${trimmedUsername}' already exists`);
        }
      }

      const updatedUser: User = {
        ...existingUser,
        ...updates,
        username: updates.username ? updates.username.trim() : existingUser.username,
      };

      this.users.set(id, updatedUser);
      return updatedUser;
    } catch (error) {
      qerrors.qerrors(error as Error, 'storage.updateUser', {
        id,
        updateFieldKeys: Object.keys(updates),
        hasUsernameUpdate: updates.username !== undefined,
        currentUsers: this.users.size,
      });
      throw error;
    }
  };

  /**
   * Removes a user record by identifier.
   *
   * @param id - Identifier to remove.
   * @returns True when deletion occurred, otherwise false.
   */
  deleteUser = async (id: number): Promise<boolean> => {
    try {
      if (typeof id !== 'number' || id < 1) return false;
      const user = this.users.get(id);
      if (user) {
        // Remove from username index
        this.usernameIndex.delete(user.username);
      }
      return this.users.delete(id);
    } catch (error) {
      qerrors.qerrors(error as Error, 'storage.deleteUser', {
        id,
        operation: 'delete',
      });
      throw error; // Re-throw to preserve error propagation
    }
  };

  /**
   * Clears the storage and resets the auto-incrementing counter.
   */
  clear = async (): Promise<void> => {
    try {
      this.users.clear();
      this.usernameIndex.clear();
      this.currentId = 1;
    } catch (error) {
      qerrors.qerrors(error as Error, 'storage.clear', {
        userCount: this.users.size,
        operation: 'clear',
      });
      throw error;
    }
  };
}

const storage = new MemStorage();
export { storage };
